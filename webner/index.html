<!DOCTYPE html>
<!--
  NER with Transformers.js

  TO RUN: Download this file and open it directly in your browser,
  or serve it locally with: python -m http.server 8000
  then visit http://localhost:8000/ner-app.html

  First run downloads ~170MB model (cached for subsequent runs)
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Redaction Tool</title>
    <!-- NER model runs in web worker (ner-worker.js) to avoid blocking UI -->
    <style>

        :root {
            /* Sky & Atmosphere */
            --sky-pale: #C5D4E0;
            --sky-clear: #7BA3C4;
            --sky-deep: #4A6B8A;

            /* Earth & Structure */
            --ochre: #C4956A;
            --terracotta: #B86B4C;
            --sand: #D9C5A0;

            /* Infrastructure */
            --concrete-light: #D4D0C8;
            --concrete: #A8A298;
            --concrete-dark: #6B6660;
            --asphalt: #3D3A36;
            --asphalt-deep: #2A2825;

            /* Industrial Accent */
            --signal-orange: #D4692A;
            --signal-yellow: #D4A932;
            --signal-red: #A63D2F;
            --industrial-green: #4A6B5A;

            /* Light */
            --white-warm: #F5F2EB;
            --white-pure: #FDFCF9;

            /* Typography */
            --font-primary: system-ui, -apple-system, 'Segoe UI', sans-serif;
            --font-mono: ui-monospace, 'SF Mono', 'Cascadia Code', 'Consolas', monospace;

            /* Type Scale */
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            --text-3xl: 1.875rem;

            --leading-tight: 1.2;
            --leading-normal: 1.5;
            --leading-relaxed: 1.7;

            --tracking-tight: -0.02em;
            --tracking-normal: 0;
            --tracking-wide: 0.05em;
            --tracking-wider: 0.1em;

            /* Spacing */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.5rem;
            --space-6: 2rem;
            --space-8: 3rem;
            --space-10: 4rem;

            /* Shadows - Single light source, directional */
            --shadow-subtle: 2px 2px 0 rgba(42, 40, 37, 0.08);
            --shadow-soft: 4px 4px 0 rgba(42, 40, 37, 0.12);
            --shadow-hard: 4px 4px 0 var(--concrete);
            --shadow-strong: 6px 6px 0 var(--concrete);

            /* Motion */
            --duration-fast: 150ms;
            --duration-normal: 250ms;
            --ease-out: cubic-bezier(0.22, 1, 0.36, 1);
        }

        /* Reset */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: var(--font-primary);
            font-size: var(--text-base);
            line-height: var(--leading-relaxed);
            color: var(--asphalt-deep);
            background: var(--white-warm);
            max-width: 56rem;
            margin: 0 auto;
            padding: var(--space-6);
            min-height: 100vh;
        }

        ::selection {
            background: var(--sky-clear);
            color: var(--white-pure);
        }

        h1 {
            font-family: var(--font-primary);
            font-size: var(--text-3xl);
            font-weight: 700;
            line-height: var(--leading-tight);
            letter-spacing: var(--tracking-tight);
            color: var(--asphalt-deep);
            margin-bottom: var(--space-2);
        }

        .subtitle {
            color: var(--concrete-dark);
            margin-bottom: var(--space-6);
            font-size: var(--text-sm);
            letter-spacing: var(--tracking-wide);
        }

        .container {
            background: var(--white-pure);
            border: 1px solid var(--concrete);
            box-shadow: var(--shadow-hard);
            overflow: hidden;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid var(--concrete);
            background: var(--white-warm);
        }

        .tab {
            padding: var(--space-3) var(--space-5);
            cursor: pointer;
            border: none;
            background: none;
            font-family: var(--font-primary);
            font-size: var(--text-sm);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            color: var(--concrete-dark);
            transition: color var(--duration-fast) var(--ease-out),
                        border-color var(--duration-fast) var(--ease-out);
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }

        .tab:hover {
            color: var(--asphalt-deep);
        }

        .tab.active {
            color: var(--asphalt-deep);
            border-bottom-color: var(--signal-orange);
        }

        .tab:focus-visible {
            outline: 3px solid var(--sky-clear);
            outline-offset: -3px;
        }

        .tab-content {
            padding: var(--space-6);
            display: none;
            min-height: 350px;
        }

        .tab-content.active {
            display: block;
        }

        .sub-tabs {
            display: flex;
            border-bottom: 1px solid var(--concrete);
            background: var(--white-warm);
            margin-bottom: var(--space-4);
        }

        .sub-tab {
            padding: var(--space-2) var(--space-4);
            cursor: pointer;
            border: none;
            background: none;
            font-family: var(--font-primary);
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            color: var(--concrete-dark);
            transition: color var(--duration-fast) var(--ease-out),
                        border-color var(--duration-fast) var(--ease-out);
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }

        .sub-tab:hover {
            color: var(--asphalt-deep);
        }

        .sub-tab.active {
            color: var(--asphalt-deep);
            border-bottom-color: var(--signal-orange);
        }

        .sub-tab:focus-visible {
            outline: 3px solid var(--sky-clear);
            outline-offset: -3px;
        }

        .sub-tab-content {
            display: none;
        }

        .sub-tab-content.active {
            display: block;
        }

        textarea {
            width: 100%;
            height: 250px;
            padding: var(--space-4);
            border: 2px solid var(--concrete);
            font-family: var(--font-primary);
            font-size: var(--text-base);
            line-height: var(--leading-relaxed);
            color: var(--asphalt-deep);
            background: var(--white-pure);
            resize: vertical;
            transition: border-color var(--duration-fast) var(--ease-out),
                        box-shadow var(--duration-fast) var(--ease-out);
        }

        textarea:hover {
            border-color: var(--concrete-dark);
        }

        textarea:focus {
            outline: none;
            border-color: var(--sky-clear);
            box-shadow: 0 0 0 3px rgba(123, 163, 196, 0.2);
        }

        textarea::placeholder {
            color: var(--concrete-dark);
        }

        .file-input {
            align-items: center;
            display: inline-flex;
            font-family: var(--font-primary);
            font-size: var(--text-sm);
            color: var(--asphalt-deep);
            border: 2px solid var(--concrete);
            padding: 0;
            background: var(--white-pure);
            height: 44px;
        }

        .file-input:focus-visible {
            outline: 3px solid var(--sky-clear);
            outline-offset: 2px;
        }

        .file-input::file-selector-button {
            background: var(--signal-orange);
            border: 0;
            border-right: 2px solid var(--concrete);
            color: var(--white-pure);
            cursor: pointer;
            font-family: var(--font-primary);
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            height: 100%;
            padding: 0 var(--space-4);
        }

        .file-input::file-selector-button:hover {
            background: var(--terracotta);
        }

        .file-input::-webkit-file-upload-button {
            background: var(--signal-orange);
            border: 0;
            border-right: 2px solid var(--concrete);
            color: var(--white-pure);
            cursor: pointer;
            font-family: var(--font-primary);
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            height: 100%;
            padding: 0 var(--space-4);
        }

        .file-input::-webkit-file-upload-button:hover {
            background: var(--terracotta);
        }

        .button-row {
            margin-top: var(--space-4);
            display: flex;
            gap: var(--space-4);
            align-items: center;
        }

        button.primary {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-5);
            font-family: var(--font-primary);
            font-size: var(--text-sm);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            background: var(--signal-orange);
            color: var(--white-pure);
            border: 2px solid var(--signal-orange);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }

        button.primary:hover:not(:disabled) {
            background: var(--terracotta);
            border-color: var(--terracotta);
        }

        button.primary:focus-visible {
            outline: 3px solid var(--sky-clear);
            outline-offset: 2px;
        }

        button.primary:disabled {
            background: var(--concrete);
            border-color: var(--concrete);
            color: var(--concrete-dark);
            cursor: not-allowed;
        }

        .status {
            color: var(--concrete-dark);
            font-size: var(--text-sm);
        }

        .status.loading {
            color: var(--signal-orange);
        }

        .status.error {
            color: var(--signal-red);
        }

        .output-text {
            line-height: 2;
            font-size: var(--text-lg);
        }

        .entity {
            padding: var(--space-1) var(--space-2);
            margin: 0 1px;
            cursor: help;
            position: relative;
            font-weight: 500;
        }

        /* Palette-matched entity colors */
        .entity-PER { background: var(--terracotta); color: var(--white-pure); }
        .entity-LOC { background: var(--industrial-green); color: var(--white-pure); }
        .entity-ORG { background: var(--sky-clear); color: var(--asphalt-deep); }
        .entity-MISC { background: var(--signal-yellow); color: var(--asphalt-deep); }

        .legend {
            display: flex;
            gap: var(--space-5);
            margin-bottom: var(--space-5);
            padding-bottom: var(--space-4);
            border-bottom: 1px solid var(--concrete);
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            color: var(--concrete-dark);
        }

        .legend-color {
            width: 16px;
            height: 16px;
        }

        .legend-color.entity-PER { background: var(--terracotta); }
        .legend-color.entity-LOC { background: var(--industrial-green); }
        .legend-color.entity-ORG { background: var(--sky-clear); }
        .legend-color.entity-MISC { background: var(--signal-yellow); }

        .no-entities {
            color: var(--concrete-dark);
            font-style: italic;
            padding: var(--space-5);
            text-align: center;
            background: var(--concrete-light);
        }

        .entity-list {
            margin-top: var(--space-6);
            padding-top: var(--space-6);
            border-top: 2px solid var(--concrete);
        }

        .entity-list h3 {
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wider);
            text-transform: uppercase;
            color: var(--concrete-dark);
            margin-bottom: var(--space-4);
        }

        .entity-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--text-sm);
        }

        .entity-table th,
        .entity-table td {
            padding: var(--space-3) var(--space-4);
            text-align: left;
            border-bottom: 1px solid var(--concrete);
        }

        .entity-table th {
            background: var(--concrete-light);
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            color: var(--concrete-dark);
            border-bottom: 2px solid var(--concrete);
        }

        .entity-table td {
            color: var(--asphalt-deep);
        }

        .entity-table tr:last-child td {
            border-bottom: none;
        }

        .entity-table tr:hover td {
            background: var(--white-warm);
        }

        .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: var(--white-pure);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (prefers-reduced-motion: reduce) {
            .spinner {
                animation: none;
                border-top-color: transparent;
            }
        }

        .cache-status {
            font-family: var(--font-mono);
            font-size: var(--text-xs);
            padding: var(--space-1) var(--space-3);
            display: inline-block;
            margin-left: auto;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
        }

        .cache-status.cached {
            background: var(--industrial-green);
            color: var(--white-pure);
        }

        .cache-status.not-cached {
            background: var(--signal-yellow);
            color: var(--asphalt-deep);
        }

        .cache-status.checking {
            background: var(--concrete-light);
            color: var(--concrete-dark);
        }

        .redacted-label {
            background: var(--asphalt-deep);
            color: var(--white-pure);
            padding: var(--space-1) var(--space-2);
            font-family: var(--font-mono);
            font-size: 0.9em;
            font-weight: 500;
        }

        .redacted-text {
            line-height: 2;
            font-size: var(--text-lg);
            margin-bottom: var(--space-6);
            padding: var(--space-4);
            background: var(--concrete-light);
            white-space: pre-wrap;
        }

        .redaction-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--text-sm);
        }

        .redaction-table th,
        .redaction-table td {
            padding: var(--space-3) var(--space-4);
            text-align: left;
            border-bottom: 1px solid var(--concrete);
        }

        .redaction-table th {
            background: var(--concrete-light);
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            color: var(--concrete-dark);
            border-bottom: 2px solid var(--concrete);
        }

        .redaction-table td {
            color: var(--asphalt-deep);
        }

        .redaction-table tr:last-child td {
            border-bottom: none;
        }

        .redaction-table tr:hover td {
            background: var(--white-warm);
        }

        .redaction-mapping {
            margin-top: var(--space-6);
            padding-top: var(--space-6);
            border-top: 2px solid var(--concrete);
        }

        .redaction-mapping h3 {
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wider);
            text-transform: uppercase;
            color: var(--concrete-dark);
            margin-bottom: var(--space-4);
        }

        .toolbar {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-3);
            justify-content: flex-end;
        }

        .toolbar-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            padding: 0;
            background: var(--white-pure);
            border: 2px solid var(--concrete);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }

        .toolbar-btn:hover:not(:disabled) {
            border-color: var(--signal-orange);
            background: var(--white-warm);
        }

        .toolbar-btn:focus-visible {
            outline: 3px solid var(--sky-clear);
            outline-offset: 2px;
        }

        .toolbar-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toolbar-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--asphalt-deep);
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .toolbar-btn.copied {
            border-color: var(--industrial-green);
            background: var(--industrial-green);
        }

        .toolbar-btn.copied svg {
            stroke: var(--white-pure);
        }

        .redaction-options {
            display: flex;
            gap: var(--space-5);
            margin-bottom: var(--space-4);
            padding: var(--space-3) var(--space-4);
            background: var(--concrete-light);
            border: 1px solid var(--concrete);
            flex-wrap: wrap;
            align-items: center;
        }

        .redaction-options-label {
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            color: var(--concrete-dark);
            margin-right: var(--space-2);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            cursor: pointer;
            accent-color: var(--signal-orange);
        }

        .checkbox-group label {
            font-size: var(--text-sm);
            color: var(--asphalt-deep);
            cursor: pointer;
            user-select: none;
        }
    </style>
</head>
<body>
    <h1>Named Entity Recognition</h1>
    <p class="subtitle">A browser based tool that will redact people's names in a text file. The model runs in the browser using transformers.js. No information leaves your computer. </p>

    <div class="container">
        <div class="tabs">
            <button class="tab active" data-tab="input">Input</button>
            <button class="tab" data-tab="output">Output</button>
            <button class="tab" data-tab="redacted">Redacted</button>
        </div>

        <div id="input" class="tab-content active">
            <textarea id="text-input" placeholder="Paste or type your text here...

Example: Apple CEO Tim Cook announced the new iPhone at their headquarters in Cupertino, California. The event was attended by journalists from The New York Times and BBC."></textarea>
            <div class="button-row">
                <button class="primary" id="run-btn">
                    <span id="btn-text">Process</span>
                </button>
                <input class="file-input" id="file-input" type="file" accept=".txt,.md,.csv,.json,text/plain,text/markdown,text/csv,application/json">
                <span class="status" id="status"></span>
                <span class="cache-status checking" id="cache-status">Checking cache...</span>
            </div>
        </div>

        <div id="output" class="tab-content">
            <div class="sub-tabs">
                <button class="sub-tab active" data-subtab="output-text" data-subtab-group="output">Text</button>
                <button class="sub-tab" data-subtab="output-entities" data-subtab-group="output">Entities</button>
            </div>

            <div id="output-text" class="sub-tab-content active" data-subtab-group="output">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color entity-PER"></div>
                        <span>Person</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color entity-LOC"></div>
                        <span>Location</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color entity-ORG"></div>
                        <span>Organization</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color entity-MISC"></div>
                        <span>Miscellaneous</span>
                    </div>
                </div>
                <div id="output-content" class="output-text">
                    <p class="no-entities">Run NER on some text to see results here.</p>
                </div>
            </div>

            <div id="output-entities" class="sub-tab-content" data-subtab-group="output">
                <div id="entity-content">
                    <p class="no-entities">Run NER on some text to see results here.</p>
                </div>
            </div>
        </div>

        <div id="redacted" class="tab-content">
            <div class="sub-tabs">
                <button class="sub-tab active" data-subtab="redacted-text" data-subtab-group="redacted">Text</button>
                <button class="sub-tab" data-subtab="redacted-mapping" data-subtab-group="redacted">Mappings</button>
            </div>

            <div id="redacted-text" class="sub-tab-content active" data-subtab-group="redacted">
                <div class="redaction-options" id="redaction-options-text">
                    <span class="redaction-options-label">Redact:</span>
                    <div class="checkbox-group">
                        <input type="checkbox" id="redact-people" checked>
                        <label for="redact-people">People</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="redact-locations">
                        <label for="redact-locations">Locations</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="redact-organizations">
                        <label for="redact-organizations">Organizations</label>
                    </div>
                </div>
                <div class="toolbar" id="redacted-toolbar" style="display: none;">
                    <button class="toolbar-btn" id="copy-redacted-btn" title="Copy to clipboard">
                        <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                    </button>
                    <button class="toolbar-btn" id="download-redacted-btn" title="Download as .txt">
                        <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    </button>
                </div>
                <div id="redacted-content">
                    <p class="no-entities">Run NER on some text to see redacted output here.</p>
                </div>
            </div>

            <div id="redacted-mapping" class="sub-tab-content" data-subtab-group="redacted">
                <div class="redaction-options" id="redaction-options-mapping">
                    <span class="redaction-options-label">Redact:</span>
                    <div class="checkbox-group">
                        <input type="checkbox" id="redact-people-mapping" checked>
                        <label for="redact-people-mapping">People</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="redact-locations-mapping">
                        <label for="redact-locations-mapping">Locations</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="redact-organizations-mapping">
                        <label for="redact-organizations-mapping">Organizations</label>
                    </div>
                </div>
                <div class="toolbar" id="mapping-toolbar" style="display: none;">
                    <button class="toolbar-btn" id="copy-mapping-btn" title="Copy to clipboard (JSON)">
                        <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                    </button>
                    <button class="toolbar-btn" id="download-mapping-btn" title="Download as .json">
                        <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    </button>
                </div>
                <div id="redacted-mapping-content">
                    <p class="no-entities">Run NER on some text to see redacted output here.</p>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import {
            escapeHtml,
            getTypeName,
            processEntities,
            aggregateEntities,
            removeOverlappingEntities,
            buildHighlightedText,
            generateRedactedText,
            splitIntoChunks
        } from './NER.js';
        import { WorkerPool, getOptimalWorkerCount } from './worker-pool.js';

        // Worker pool for parallel NER processing
        let workerPool = null;
        let isModelLoaded = false;
        let isModelLoading = false;
        let isProcessing = false;
        const MODEL_ID = 'Xenova/bert-base-NER';

        // Calculate optimal worker count (capped at 4)
        let activeWorkerCount = getOptimalWorkerCount();
        console.log(`Optimal worker count: ${activeWorkerCount} (cores: ${navigator.hardwareConcurrency || 'unknown'})`);

        // Initialize the worker pool
        async function initWorkerPool() {
            if (workerPool && isModelLoaded) return;

            if (isModelLoading) return;

            isModelLoading = true;
            status.textContent = `Loading NER model across ${activeWorkerCount} worker${activeWorkerCount > 1 ? 's' : ''}...`;
            status.className = 'status loading';
            runBtn.disabled = true;
            btnText.innerHTML = '<div class="spinner"></div>';

            try {
                workerPool = new WorkerPool('./ner-worker.js', activeWorkerCount);
                await workerPool.initialize((progressData) => {
                    // Model download progress (from first worker)
                    if (progressData.status === 'downloading') {
                        const pct = progressData.progress ? Math.round(progressData.progress) : 0;
                        status.textContent = `Downloading model... ${pct}%`;
                    } else if (progressData.status === 'loading') {
                        status.textContent = 'Loading model into memory...';
                    }
                });

                isModelLoaded = true;
                isModelLoading = false;
                const workerText = activeWorkerCount > 1 ? `${activeWorkerCount} workers` : '1 worker';
                status.textContent = `Model loaded (${workerText} ready)`;
                status.className = 'status';
                checkModelCache();
                setTimeout(() => { status.textContent = ''; }, 2000);
                runBtn.disabled = false;
                btnText.textContent = 'Process';
            } catch (err) {
                console.error('Worker pool initialization error:', err);

                // Graceful degradation: try single worker if multi-worker fails
                if (activeWorkerCount > 1) {
                    console.log('Falling back to single worker...');
                    activeWorkerCount = 1;
                    workerPool = null;
                    isModelLoading = false;
                    status.textContent = 'Retrying with single worker...';
                    return initWorkerPool(); // Retry with single worker
                }

                status.textContent = 'Error loading model: ' + err.message;
                status.className = 'status error';
                isModelLoading = false;
                runBtn.disabled = false;
                btnText.textContent = 'Process';
                throw err;
            }
        }

        const textInput = document.getElementById('text-input');
        const runBtn = document.getElementById('run-btn');
        const btnText = document.getElementById('btn-text');
        const status = document.getElementById('status');
        const outputContent = document.getElementById('output-content');
        const entityContent = document.getElementById('entity-content');
        const redactedContent = document.getElementById('redacted-content');
        const redactedMappingContent = document.getElementById('redacted-mapping-content');
        const redactedToolbar = document.getElementById('redacted-toolbar');
        const copyRedactedBtn = document.getElementById('copy-redacted-btn');
        const downloadRedactedBtn = document.getElementById('download-redacted-btn');
        const mappingToolbar = document.getElementById('mapping-toolbar');
        const copyMappingBtn = document.getElementById('copy-mapping-btn');
        const downloadMappingBtn = document.getElementById('download-mapping-btn');
        const tabs = document.querySelectorAll('.tab');
        let currentRedactedText = ''; // Store plain text for copy/download
        let currentMapping = []; // Store mapping for copy/download
        let uploadedFileName = ''; // Store uploaded file name for download naming
        let currentText = ''; // Store original text for re-rendering
        let currentAggregatedEntities = []; // Store entities for re-rendering
        const tabContents = document.querySelectorAll('.tab-content');

        // Redaction checkbox elements
        const redactPeopleCheckbox = document.getElementById('redact-people');
        const redactLocationsCheckbox = document.getElementById('redact-locations');
        const redactOrganizationsCheckbox = document.getElementById('redact-organizations');
        const redactPeopleMappingCheckbox = document.getElementById('redact-people-mapping');
        const redactLocationsMappingCheckbox = document.getElementById('redact-locations-mapping');
        const redactOrganizationsMappingCheckbox = document.getElementById('redact-organizations-mapping');
        const subTabs = document.querySelectorAll('.sub-tab');
        const subTabContents = document.querySelectorAll('.sub-tab-content');
        const cacheStatus = document.getElementById('cache-status');
        const fileInput = document.getElementById('file-input');

        // Check if model is cached using Cache API
        async function checkModelCache() {
            try {
                const cache = await caches.open('transformers-cache');
                const keys = await cache.keys();
                // Look for any cached files from our model
                const modelCached = keys.some(req => req.url.includes(MODEL_ID.replace('/', '%2F')) || req.url.includes(MODEL_ID));

                if (modelCached) {
                    cacheStatus.textContent = 'Model cached';
                    cacheStatus.className = 'cache-status cached';
                } else {
                    cacheStatus.textContent = 'Model not cached';
                    cacheStatus.className = 'cache-status not-cached';
                }
                return modelCached;
            } catch (e) {
                // Cache API not available or error
                console.log('Cache check error:', e);
                cacheStatus.textContent = 'Cache unavailable';
                cacheStatus.className = 'cache-status not-cached';
                return false;
            }
        }

        // Check cache on page load
        checkModelCache();

        // Tab switching
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.dataset.tab;
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tabId).classList.add('active');
            });
        });

        function setSubTab(group, subTabId) {
            const groupTabs = document.querySelectorAll(`.sub-tab[data-subtab-group="${group}"]`);
            const groupContents = document.querySelectorAll(`.sub-tab-content[data-subtab-group="${group}"]`);
            groupTabs.forEach(t => t.classList.remove('active'));
            groupContents.forEach(c => c.classList.remove('active'));
            const activeTab = document.querySelector(`[data-subtab="${subTabId}"][data-subtab-group="${group}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }
            const activeContent = document.getElementById(subTabId);
            if (activeContent) {
                activeContent.classList.add('active');
            }
        }

        subTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                setSubTab(tab.dataset.subtabGroup, tab.dataset.subtab);
            });
        });

        // Load model via worker pool
        async function loadModel() {
            if (isModelLoaded) return true;
            if (isModelLoading) return false;

            try {
                await initWorkerPool();
                return true;
            } catch (err) {
                return false;
            }
        }

        // Stop NER processing
        function stopNER() {
            if (workerPool && isProcessing) {
                workerPool.stopAll();
                isProcessing = false;
                runBtn.disabled = false;
                btnText.textContent = 'Process';
                status.textContent = 'Processing stopped.';
                status.className = 'status';
            }
        }

        // Run NER via worker pool (parallel processing)
        async function runNER() {
            const text = textInput.value.trim();
            if (!text) {
                status.textContent = 'Please enter some text first.';
                status.className = 'status error';
                return;
            }

            isProcessing = true;
            runBtn.disabled = false;
            btnText.textContent = 'Stop';
            status.textContent = 'Analyzing text...';
            status.className = 'status loading';

            try {
                // Ensure model is loaded first
                const loaded = await loadModel();
                if (!loaded) {
                    isProcessing = false;
                    btnText.textContent = 'Process';
                    return;
                }

                // Update button back to Stop after model load (which may have changed it)
                btnText.textContent = 'Stop';

                // Split text into chunks
                const chunks = splitIntoChunks(text);
                const effectiveWorkers = Math.min(activeWorkerCount, chunks.length);
                const workerInfo = effectiveWorkers > 1 ? ` (${effectiveWorkers} workers)` : '';

                // Process chunks in parallel via worker pool
                const result = await workerPool.processChunks(chunks, (completed, total) => {
                    status.textContent = `Analyzing chunk ${completed} of ${total}...${workerInfo}`;
                });

                if (result.stopped) {
                    // User stopped processing
                    return;
                }

                const { entities, chunkCount } = result;
                console.log('Input text:', text);

                displayResults(text, entities);

                // Switch to output tab
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                document.querySelector('[data-tab="output"]').classList.add('active');
                document.getElementById('output').classList.add('active');
                setSubTab('output', 'output-text');

                const entityCount = processEntities(text, entities).length;
                status.textContent = `Found ${entityCount} entities in ${chunkCount} chunk${chunkCount > 1 ? 's' : ''}${workerInfo}`;
                status.className = 'status';
            } catch (error) {
                // Don't show error for user-initiated stop
                if (error.message !== 'stopped') {
                    console.error('NER error:', error);
                    status.textContent = 'Error: ' + error.message;
                    status.className = 'status error';
                }
            } finally {
                isProcessing = false;
                runBtn.disabled = false;
                btnText.textContent = 'Process';
            }
        }

        // Display results using imported NER functions
        function displayResults(text, entities) {
            console.log('displayResults called with:', entities);

            // Process entities using imported functions
            const processed = processEntities(text, entities);
            console.log('Processed entities (before aggregation):', processed);

            const aggregated = aggregateEntities(text, processed);
            console.log('Processed entities (after aggregation):', aggregated);

            // Store for re-rendering when checkboxes change
            currentText = text;
            currentAggregatedEntities = aggregated;

            if (aggregated.length === 0) {
                outputContent.innerHTML = escapeHtml(text);
                entityContent.innerHTML = '<p class="no-entities">No named entities found in this text.</p>';
                return;
            }

            // Remove overlapping entities
            const nonOverlapping = removeOverlappingEntities(aggregated);

            // Build highlighted text
            const highlighted = buildHighlightedText(text, nonOverlapping);

            // Build entity table
            const uniqueEntities = [...aggregated].sort((a, b) => a.start - b.start);
            let tableRows = uniqueEntities.map(e => {
                const type = e.entity_group.replace('B-', '').replace('I-', '');
                return `
                    <tr>
                        <td><span class="entity entity-${type}">${escapeHtml(e.word)}</span></td>
                        <td>${getTypeName(type)}</td>
                        <td>${(e.score * 100).toFixed(1)}%</td>
                    </tr>
                `;
            }).join('');

            outputContent.innerHTML = highlighted;
            entityContent.innerHTML = `
                <div class="entity-list">
                    <h3>Detected Entities</h3>
                    <table class="entity-table">
                        <thead>
                            <tr>
                                <th>Entity</th>
                                <th>Type</th>
                                <th>Confidence</th>
                            </tr>
                        </thead>
                        <tbody>${tableRows}</tbody>
                    </table>
                </div>
            `;

            // Also populate the redacted tab
            displayRedacted(text, aggregated);
        }

        // Get current redaction options from checkboxes
        function getRedactionOptions() {
            return {
                redactPeople: redactPeopleCheckbox.checked,
                redactLocations: redactLocationsCheckbox.checked,
                redactOrganizations: redactOrganizationsCheckbox.checked
            };
        }

        // Display redacted version with entities replaced
        function displayRedacted(text, entities) {
            const options = getRedactionOptions();
            const { redactedText, mapping } = generateRedactedText(text, entities, options);

            // Check if any redaction type is enabled
            const anyEnabled = options.redactPeople || options.redactLocations || options.redactOrganizations;

            if (mapping.length === 0) {
                currentRedactedText = text; // No redactions, use original text
                currentMapping = [];
                redactedToolbar.style.display = 'flex';
                mappingToolbar.style.display = 'none';
                const message = anyEnabled
                    ? 'No matching entities found to redact.'
                    : 'Select at least one entity type to redact.';
                redactedContent.innerHTML = `
                    <div class="redacted-text">${escapeHtml(text)}</div>
                    <p class="no-entities">${message}</p>
                `;
                redactedMappingContent.innerHTML = `<p class="no-entities">${message}</p>`;
                return;
            }

            // Store plain text and mapping for copy/download
            currentRedactedText = redactedText;
            currentMapping = mapping;
            redactedToolbar.style.display = 'flex';
            mappingToolbar.style.display = 'flex';

            // Convert plain text redaction to HTML with styled labels
            let htmlRedactedText = escapeHtml(redactedText);
            for (const { redacted } of mapping) {
                htmlRedactedText = htmlRedactedText.replace(
                    new RegExp(`\\[${redacted}\\]`, 'g'),
                    `<span class="redacted-label">${redacted}</span>`
                );
            }

            // Build mapping table with type column
            const tableRows = mapping.map(({ original, redacted, type }) => `
                <tr>
                    <td>${escapeHtml(original)}</td>
                    <td><span class="redacted-label">${redacted}</span></td>
                    <td>${type.charAt(0).toUpperCase() + type.slice(1)}</td>
                </tr>
            `).join('');

            redactedContent.innerHTML = `
                <div class="redacted-text">${htmlRedactedText}</div>
            `;
            redactedMappingContent.innerHTML = `
                <div class="redaction-mapping">
                    <h3>Entity Mapping</h3>
                    <table class="redaction-table">
                        <thead>
                            <tr>
                                <th>Original</th>
                                <th>Redacted As</th>
                                <th>Type</th>
                            </tr>
                        </thead>
                        <tbody>${tableRows}</tbody>
                    </table>
                </div>
            `;
        }

        runBtn.addEventListener('click', () => {
            if (isProcessing) {
                stopNER();
            } else {
                runNER();
            }
        });

        // Allow Ctrl+Enter to run
        textInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                runNER();
            }
        });

        // Clear output when input text changes
        textInput.addEventListener('input', (e) => {
            // Reset output to default state
            outputContent.innerHTML = '<p class="no-entities">Run NER on some text to see results here.</p>';
            entityContent.innerHTML = '<p class="no-entities">Run NER on some text to see results here.</p>';
            redactedContent.innerHTML = '<p class="no-entities">Run NER on some text to see redacted output here.</p>';
            redactedMappingContent.innerHTML = '<p class="no-entities">Run NER on some text to see redacted output here.</p>';
            redactedToolbar.style.display = 'none';
            mappingToolbar.style.display = 'none';
            currentRedactedText = '';
            currentMapping = [];
            currentText = '';
            currentAggregatedEntities = [];
            // Clear uploaded filename if user is manually typing (not from file load)
            // inputType is present for real user input, absent for programmatic dispatch
            if (e.inputType) {
                uploadedFileName = '';
            }
            // Clear status
            status.textContent = '';
            status.className = 'status';
        });

        // Copy redacted text to clipboard
        copyRedactedBtn.addEventListener('click', async () => {
            if (!currentRedactedText) return;
            try {
                await navigator.clipboard.writeText(currentRedactedText);
                copyRedactedBtn.classList.add('copied');
                setTimeout(() => {
                    copyRedactedBtn.classList.remove('copied');
                }, 1500);
            } catch (err) {
                console.error('Failed to copy:', err);
                status.textContent = 'Failed to copy to clipboard';
                status.className = 'status error';
            }
        });

        // Generate download filename based on uploaded file
        function getRedactedFileName(extension) {
            if (!uploadedFileName) {
                return `redacted_text.${extension}`;
            }
            const lastDot = uploadedFileName.lastIndexOf('.');
            if (lastDot === -1) {
                return `${uploadedFileName}_redacted.${extension}`;
            }
            const baseName = uploadedFileName.substring(0, lastDot);
            return `${baseName}_redacted.${extension}`;
        }

        // Download redacted text as .txt file
        downloadRedactedBtn.addEventListener('click', () => {
            if (!currentRedactedText) return;
            const blob = new Blob([currentRedactedText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = getRedactedFileName('txt');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Copy mapping as JSON to clipboard
        copyMappingBtn.addEventListener('click', async () => {
            if (!currentMapping.length) return;
            try {
                const json = JSON.stringify(currentMapping, null, 2);
                await navigator.clipboard.writeText(json);
                copyMappingBtn.classList.add('copied');
                setTimeout(() => {
                    copyMappingBtn.classList.remove('copied');
                }, 1500);
            } catch (err) {
                console.error('Failed to copy:', err);
                status.textContent = 'Failed to copy to clipboard';
                status.className = 'status error';
            }
        });

        // Download mapping as .json file
        downloadMappingBtn.addEventListener('click', () => {
            if (!currentMapping.length) return;
            const json = JSON.stringify(currentMapping, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = getRedactedFileName('json');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        fileInput.addEventListener('change', () => {
            const file = fileInput.files && fileInput.files[0];
            if (!file) return;

            // Store filename for download naming
            uploadedFileName = file.name;

            const reader = new FileReader();
            reader.onload = () => {
                textInput.value = reader.result || '';
                textInput.dispatchEvent(new Event('input', { bubbles: true }));
                textInput.focus();
                fileInput.value = '';
            };
            reader.onerror = () => {
                status.textContent = 'Could not read the selected file.';
                status.className = 'status error';
                fileInput.value = '';
            };
            reader.readAsText(file);
        });

        // Sync checkboxes between Text and Mapping tabs
        function syncCheckboxes(sourcePrefix) {
            const isText = sourcePrefix === '';
            const textCheckboxes = [redactPeopleCheckbox, redactLocationsCheckbox, redactOrganizationsCheckbox];
            const mappingCheckboxes = [redactPeopleMappingCheckbox, redactLocationsMappingCheckbox, redactOrganizationsMappingCheckbox];

            if (isText) {
                // Sync from text to mapping
                mappingCheckboxes.forEach((cb, i) => {
                    cb.checked = textCheckboxes[i].checked;
                });
            } else {
                // Sync from mapping to text
                textCheckboxes.forEach((cb, i) => {
                    cb.checked = mappingCheckboxes[i].checked;
                });
            }
        }

        // Re-render redacted content when checkboxes change
        function onCheckboxChange(sourcePrefix) {
            syncCheckboxes(sourcePrefix);
            if (currentText && currentAggregatedEntities.length > 0) {
                displayRedacted(currentText, currentAggregatedEntities);
            }
        }

        // Add event listeners for checkboxes in Text tab
        redactPeopleCheckbox.addEventListener('change', () => onCheckboxChange(''));
        redactLocationsCheckbox.addEventListener('change', () => onCheckboxChange(''));
        redactOrganizationsCheckbox.addEventListener('change', () => onCheckboxChange(''));

        // Add event listeners for checkboxes in Mapping tab
        redactPeopleMappingCheckbox.addEventListener('change', () => onCheckboxChange('mapping'));
        redactLocationsMappingCheckbox.addEventListener('change', () => onCheckboxChange('mapping'));
        redactOrganizationsMappingCheckbox.addEventListener('change', () => onCheckboxChange('mapping'));
    </script>
</body>
</html>

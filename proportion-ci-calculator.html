<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proportion Confidence Interval Calculator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #f8fafc;
      color: #0f172a;
      min-height: 100vh;
      line-height: 1.5;
    }
    
    .container {
      max-width: 72rem;
      margin: 0 auto;
      padding: 1.5rem;
    }
    
    @media (min-width: 768px) {
      .container { padding: 2.5rem; }
    }
    
    .header h1 {
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: -0.025em;
    }
    
    @media (min-width: 768px) {
      .header h1 { font-size: 1.875rem; }
    }
    
    .header p {
      margin-top: 0.5rem;
      font-size: 0.875rem;
      color: #475569;
    }
    
    .grid {
      display: grid;
      gap: 1.5rem;
      margin-top: 1.5rem;
    }
    
    @media (min-width: 768px) {
      .grid { grid-template-columns: 1fr 1fr; align-items: start; }
    }
    
    .card {
      background: white;
      border-radius: 1rem;
      border: 1px solid #e2e8f0;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      padding: 1.25rem;
    }
    
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .card h2 {
      font-size: 1.125rem;
      font-weight: 600;
    }
    
    .mode-buttons {
      display: flex;
      gap: 0.5rem;
    }
    
    .pill-btn {
      padding: 0.375rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      background: white;
      color: #334155;
      cursor: pointer;
      transition: all 0.15s;
    }

    .pill-btn:hover {
      background: #f8fafc;
    }

    .pill-btn.active {
      background: #0f172a;
      color: white;
      border-color: #0f172a;
    }
    
    .inputs {
      margin-top: 1rem;
      display: grid;
      gap: 1rem;
    }
    
    .field label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.5rem;
    }
    
    .field input, .field select, .fpc-field input {
      width: 100%;
      border-radius: 0.75rem;
      border: 1px solid #e2e8f0;
      padding: 0.5rem 0.75rem;
      font-size: 1rem;
      outline: none;
      transition: box-shadow 0.15s;
    }

    .field input:focus, .field select:focus, .fpc-field input:focus {
      box-shadow: 0 0 0 2px #cbd5e1;
    }

    .field input:disabled, .fpc-field input:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .field .hint {
      font-size: 0.75rem;
      color: #64748b;
      margin-top: 0.5rem;
    }
    
    .preset-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    /* .preset-btn uses .pill-btn base styles */
    
    .fpc-box {
      border-radius: 1rem;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    
    .fpc-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }
    
    .fpc-title {
      font-size: 0.875rem;
      font-weight: 600;
    }
    
    .fpc-subtitle {
      font-size: 0.75rem;
      color: #64748b;
    }
    
    .checkbox-label {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      cursor: pointer;
    }
    
    .checkbox-label input {
      width: 1rem;
      height: 1rem;
    }
    
    .fpc-field.disabled {
      opacity: 0.5;
    }
    
    .warning {
      border-radius: 0.75rem;
      border: 1px solid #fde68a;
      background: #fefce8;
      padding: 0.75rem;
      font-size: 0.875rem;
      color: #78350f;
    }
    
    .results-placeholder {
      margin-top: 1.5rem;
      font-size: 0.875rem;
      color: #475569;
    }
    
    .results {
      margin-top: 1rem;
      display: grid;
      gap: 1rem;
    }
    
    .result-main {
      background: #0f172a;
      color: white;
      border-radius: 1rem;
      padding: 1rem;
    }
    
    .result-main .label {
      font-size: 0.875rem;
      color: #cbd5e1;
    }
    
    .result-main .method-name {
      margin-top: 0.25rem;
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .bounds-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }
    
    .bound-box {
      background: rgba(255,255,255,0.1);
      border-radius: 0.75rem;
      padding: 0.75rem;
    }
    
    .bound-box .bound-label {
      font-size: 0.75rem;
      color: #cbd5e1;
    }
    
    .bound-box .bound-value {
      margin-top: 0.25rem;
      font-size: 1.125rem;
      font-weight: 600;
    }
    
    .bound-box .bound-pct {
      font-size: 0.75rem;
      color: #cbd5e1;
    }
    
    .stat-row {
      margin-top: 0.75rem;
    }
    
    .stat-box {
      background: rgba(255,255,255,0.1);
      border-radius: 0.75rem;
      padding: 0.75rem;
      text-align: center;
      margin-bottom: 0.75rem;
    }
    
    .stat-box .stat-label {
      font-size: 0.75rem;
      color: #cbd5e1;
    }
    
    .stat-box .stat-value {
      margin-top: 0.25rem;
      font-size: 1.125rem;
      font-weight: 600;
    }
    
    .details-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
      font-size: 0.875rem;
    }
    
    .detail-item .detail-label {
      color: #64748b;
    }
    
    .detail-item .detail-value {
      font-weight: 600;
    }
    
    .detail-note {
      margin-top: 0.5rem;
      font-size: 0.75rem;
      color: #64748b;
    }
    
    .methods-section .methods-title {
      font-size: 0.875rem;
      font-weight: 600;
    }
    
    .methods-list {
      margin-top: 0.75rem;
      display: grid;
      gap: 0.5rem;
      font-size: 0.875rem;
    }
    
    .method-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid #e2e8f0;
      padding: 0.5rem 0.75rem;
      background: white;
      color: #0f172a;
    }
    
    .method-row.active {
      background: #0f172a;
      border-color: #0f172a;
      color: white;
    }
    
    .method-row .method-label {
      font-weight: 500;
    }
    
    .method-row .method-values {
      font-variant-numeric: tabular-nums;
    }
    
    .method-row.active .method-values {
      color: white;
    }
    
    .method-row:not(.active) .method-values {
      color: #334155;
    }
    
    .guidance {
      border-radius: 1rem;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
      padding: 1rem;
      font-size: 0.75rem;
      color: #334155;
    }
    
    .guidance .guidance-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    
    .guidance ul {
      padding-left: 1.25rem;
    }
    
    .guidance li {
      margin-top: 0.25rem;
    }
    
    .formula-section {
      margin-top: 2rem;
    }
    
    .formula-section h3 {
      font-size: 1rem;
      font-weight: 600;
    }
    
    .formula-box {
      margin-top: 0.5rem;
      border-radius: 0.75rem;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      padding: 0.75rem;
      font-family: monospace;
      font-size: 0.875rem;
      overflow-x: auto;
    }
    
    .formula-note {
      margin-top: 0.5rem;
      font-size: 0.75rem;
      color: #64748b;
    }

    .sweep-results {
      margin-top: 1rem;
    }

    .sweep-chart-container {
      background: white;
      border-radius: 1rem;
      border: 1px solid #e2e8f0;
      padding: 1rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      height: 500px;
    }

    .sweep-3d-chart-container {
      background: white;
      border-radius: 1rem;
      border: 1px solid #e2e8f0;
      padding: 1rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      height: 600px;
      min-width: 0;
      overflow: hidden;
    }

    .sweep-info {
      margin-top: 0.75rem;
      font-size: 0.875rem;
      color: #475569;
    }

    .sweep-description {
      margin: 0;
    }

    .sweep-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    /* sweep-tab overrides pill-btn with different padding and border-radius */
    .sweep-tab {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }

    .sweep-tab-panel {
      display: none;
    }

    .sweep-tab-panel.active {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Proportion Confidence Interval Calculator</h1>
      <p>Confidence intervals for a population proportion using only a sample proportion (or successes) and sample size — no standard deviation required.</p>
    </div>
    
    <div class="grid">
      <!-- Inputs Panel -->
      <div class="card">
        <div class="card-header">
          <h2>Inputs</h2>
          <div class="mode-buttons">
            <button class="pill-btn" id="mode-successes" onclick="setMode('successes')">Use successes (x)</button>
            <button class="pill-btn" id="mode-proportion" onclick="setMode('proportion')">Use proportion (p)</button>
            <button class="pill-btn active" id="mode-sweep" onclick="setMode('sweep')">Sweep range</button>
          </div>
        </div>

        <div class="inputs">
          <div class="field" id="successes-field" style="display: none;">
            <label>Successes (x)</label>
            <input type="text" id="input-x" value="50" inputmode="decimal" placeholder="e.g., 50" oninput="calculate()">
            <p class="hint">Number of "successes" / positive observations in your sample.</p>
          </div>
          
          <div class="field" id="proportion-field" style="display: none;">
            <label>Sample proportion (p)</label>
            <input type="text" id="input-p" value="0.5" inputmode="decimal" placeholder="e.g., 0.5" oninput="calculate()">
            <p class="hint">Must be between 0 and 1 (e.g., 0.37 for 37%).</p>
          </div>
          
          <div class="field">
            <label>Sample size (n)</label>
            <input type="text" id="input-n" value="100" inputmode="numeric" placeholder="e.g., 100" oninput="calculate()">
          </div>
          
          <div class="field">
            <label>Confidence level</label>
            <input type="text" id="input-conf" value="0.95" inputmode="decimal" placeholder="e.g., 0.95" oninput="calculate()">
            <div class="preset-buttons">
              <button class="pill-btn" onclick="setConf(0.9)">90%</button>
              <button class="pill-btn" onclick="setConf(0.95)">95%</button>
              <button class="pill-btn" onclick="setConf(0.99)">99%</button>
            </div>
            <p class="hint">Enter as a decimal between 0 and 1 (0.95 = 95%).</p>
          </div>
          
          <div class="field">
            <label>Interval method</label>
            <select id="input-method" onchange="calculate()">
              <option value="hypergeo">Hypergeometric score (finite-pop Wilson)</option>
              <option value="wilson">Wilson score</option>
              <option value="agresti">Agresti–Coull</option>
              <option value="wald">Wald (normal approximation)</option>
            </select>
            <p class="hint">Hypergeometric score is a finite-population Wilson analogue that uses N.</p>
          </div>
          
          <div class="fpc-box" style="display: none;">

            <div class="fpc-field" id="pop-field">
              <label style="font-size: 0.875rem; font-weight: 500; display: block; margin-bottom: 0.5rem;">Population size (N)</label>
              <input type="text" id="input-N" value="1000" inputmode="numeric" placeholder="e.g., 10000" oninput="calculate()">
              <p class="hint">Required for Hypergeometric score, and for Wald+FPC when enabled.</p>
            </div>

            <div class="fpc-header">
              <div>
                <div class="fpc-title">Finite population correction</div>
                <div class="fpc-subtitle">Checkbox applies to Wald only; Hypergeometric score uses N directly.</div>
              </div>
              <label class="checkbox-label">
                <input type="checkbox" id="input-fpc" onchange="calculate()">
                Enable (Wald)
              </label>
            </div>

          </div>
          
          <div class="warning" id="warning" style="display: none;">
            Please enter valid inputs: n &gt; 0, confidence between 0 and 1, and p in [0,1] (or successes x between 0 and n).
          </div>
        </div>
      </div>
      
      <!-- Results Panel -->
      <div class="card">
        <h2>Results</h2>
        
        <div id="results-placeholder" class="results-placeholder">
          Enter inputs to see your confidence interval.
        </div>
        
        <div id="sweep-results" class="sweep-results" style="display: none;">
          <div id="sweep-tabs" class="sweep-tabs"></div>
          <div id="sweep-panels"></div>
          <div class="sweep-info">
            <p class="sweep-description">Showing confidence interval bounds as successes (x) varies from 0 to n.</p>
          </div>
        </div>

        <div id="results" class="results" style="display: none;">
          <div class="result-main">
            <div class="label">Selected method</div>
            <div class="method-name" id="chosen-method">Wilson score</div>
            
            <div class="bounds-grid">
              <div class="bound-box">
                <div class="bound-label">Lower bound</div>
                <div class="bound-value" id="chosen-lo-count">40</div>
                <div class="bound-pct" id="chosen-lo-pct">40.20%</div>
              </div>
              <div class="bound-box">
                <div class="bound-label">Upper bound</div>
                <div class="bound-value" id="chosen-hi-count">60</div>
                <div class="bound-pct" id="chosen-hi-pct">59.80%</div>
              </div>
            </div>
            
            <div class="stat-row">
              <div class="stat-box">
                <div class="stat-label">Total confidence interval width</div>
                <div class="stat-value" id="chosen-width">19.60%</div>
              </div>
              <div class="stat-box">
                <div class="stat-label">Relative standard error (RSE)</div>
                <div class="stat-value" id="chosen-rse">10.00%</div>
              </div>
            </div>
          </div>
          
          <div class="card" style="padding: 1rem;">
            <div class="details-grid">
              <div class="detail-item">
                <div class="detail-label">Sample size (n)</div>
                <div class="detail-value" id="detail-n">100</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Successes (x)</div>
                <div class="detail-value" id="detail-x">50</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">z value</div>
                <div class="detail-value" id="detail-z">1.959964</div>
              </div>
              <div class="detail-item">
                <div class="detail-label">Population model</div>
                <div class="detail-value" id="detail-model">Binomial (default)</div>
              </div>
            </div>
            <div class="detail-note" id="detail-note">Population size not used</div>
          </div>
          
          <div class="card methods-section" style="padding: 1rem;">
            <div class="methods-title">All methods</div>
            <div class="methods-list">
              <div class="method-row" id="row-wilson">
                <div class="method-label">Wilson score</div>
                <div class="method-values" id="val-wilson">40 → 60 · 40.20% → 59.80%</div>
              </div>
              <div class="method-row" id="row-hypergeo">
                <div class="method-label">Hypergeometric score (finite-pop Wilson)</div>
                <div class="method-values" id="val-hypergeo">40 → 60 · 40.20% → 59.80%</div>
              </div>
              <div class="method-row" id="row-agresti">
                <div class="method-label">Agresti–Coull</div>
                <div class="method-values" id="val-agresti">40 → 60 · 40.20% → 59.80%</div>
              </div>
              <div class="method-row" id="row-wald">
                <div class="method-label">Wald (normal approx)</div>
                <div class="method-values" id="val-wald">40 → 60 · 40.20% → 59.80%</div>
              </div>
            </div>
          </div>
          
          <div class="guidance">
            <div class="guidance-title">Quick guidance</div>
            <ul>
              <li>If n is small or p is near 0 or 1, prefer Wilson.</li>
              <li>If sampling without replacement from a finite population, consider Hypergeometric score (or Wald+FPC).</li>
              <li>Wald matches: p ± z √(p(1−p)/n).</li>
              <li>FPC is appropriate when sampling without replacement from a finite population (and the sampling fraction n/N is not tiny). In this calculator it applies to the Wald interval only. The Hypergeometric score method directly uses N.</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // State
    let mode = 'sweep';
    let sweepCharts = {};
    let activeTabIndex = 0;

    // Acklam's approximation for inverse normal CDF
    function normInv(p) {
      if (!(p > 0 && p < 1)) return NaN;

      const a = [
        -3.969683028665376e1, 2.209460984245205e2, -2.759285104469687e2,
        1.38357751867269e2, -3.066479806614716e1, 2.506628277459239
      ];
      const b = [
        -5.447609879822406e1, 1.615858368580409e2, -1.556989798598866e2,
        6.680131188771972e1, -1.328068155288572e1
      ];
      const c = [
        -7.784894002430293e-3, -3.223964580411365e-1, -2.400758277161838,
        -2.549732539343734, 4.374664141464968, 2.938163982698783
      ];
      const d = [
        7.784695709041462e-3, 3.224671290700398e-1, 2.445134137142996, 3.754408661907416
      ];

      const plow = 0.02425;
      const phigh = 1 - plow;

      let q, r;

      if (p < plow) {
        q = Math.sqrt(-2 * Math.log(p));
        return (((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
               ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
      }

      if (p > phigh) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        return -(((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
                ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
      }

      q = p - 0.5;
      r = q * q;
      const num = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5]) * q;
      const den = (((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1);
      return num / den;
    }

    function clamp01(x) {
      return Math.min(1, Math.max(0, x));
    }

    function fmtPct(x) {
      if (!Number.isFinite(x)) return '—';
      return (x * 100).toFixed(2) + '%';
    }

    function fmtNum(x, dp = 6) {
      if (!Number.isFinite(x)) return '—';
      return x.toFixed(dp);
    }

    function fmtCount(x, dp = 0) {
      if (!Number.isFinite(x)) return '—';
      return x.toFixed(dp);
    }

    function isValidFinitePopParams(n, N) {
      return Number.isFinite(n) && Number.isFinite(N) && N > 1 && n >= 0 && n <= N;
    }

    function finitePopulationFactor(n, N) {
      if (!isValidFinitePopParams(n, N)) return NaN;
      return (N - n) / (N - 1);
    }

    function finitePopulationCorrection(n, N) {
      const factor = finitePopulationFactor(n, N);
      return Number.isFinite(factor) ? Math.sqrt(factor) : NaN;
    }

    function bisectRoot(fn, lo, hi, maxIter = 80, tol = 1e-12) {
      let fLo = fn(lo);
      let fHi = fn(hi);
      if (!Number.isFinite(fLo) || !Number.isFinite(fHi)) return NaN;
      if (fLo === 0) return lo;
      if (fHi === 0) return hi;
      if (fLo * fHi > 0) return NaN;

      let a = lo, b = hi, fa = fLo, fb = fHi;

      for (let i = 0; i < maxIter; i++) {
        const mid = (a + b) / 2;
        const fm = fn(mid);
        if (!Number.isFinite(fm)) return NaN;
        if (Math.abs(fm) < tol || b - a < tol) return mid;
        if (fa * fm <= 0) { b = mid; fb = fm; }
        else { a = mid; fa = fm; }
      }
      return (a + b) / 2;
    }

    function bracketRoot(fn, lo, hi, steps = 400) {
      let prevX = lo;
      let prevF = fn(prevX);
      if (!Number.isFinite(prevF)) return null;
      for (let i = 1; i <= steps; i++) {
        const x = lo + (i * (hi - lo)) / steps;
        const f = fn(x);
        if (!Number.isFinite(f)) continue;
        if (prevF === 0) return { a: prevX, b: prevX };
        if (f === 0) return { a: x, b: x };
        if (prevF * f < 0) return { a: prevX, b: x };
        prevX = x;
        prevF = f;
      }
      return null;
    }

    function hypergeoScoreCI(x, n, N, z) {
      if (!(Number.isFinite(x) && Number.isFinite(n) && Number.isFinite(N) && Number.isFinite(z))) {
        return { lo: NaN, hi: NaN };
      }
      if (n <= 0) return { lo: NaN, hi: NaN };
      if (N <= 1 || n > N) return { lo: NaN, hi: NaN };
      if (x < 0 || x > n) return { lo: NaN, hi: NaN };

      const pHat = x / n;
      const f = finitePopulationFactor(n, N);

      if (f === 0) return { lo: clamp01(pHat), hi: clamp01(pHat) };

      const eps = 1e-12;
      const score = (p) => {
        const pp = Math.min(1 - eps, Math.max(eps, p));
        const denom = Math.sqrt(n * pp * (1 - pp) * f);
        return (x - n * pp) / denom;
      };

      const solveForTarget = (target) => {
        const fn = (p) => score(p) - target;
        const br = bracketRoot(fn, eps, 1 - eps);
        if (!br) return NaN;
        if (br.a === br.b) return br.a;
        return bisectRoot(fn, br.a, br.b);
      };

      let lo = 0, hi = 1;

      if (x === 0) {
        lo = 0;
        const solHi = solveForTarget(-z);
        hi = Number.isFinite(solHi) ? solHi : 1;
      } else if (x === n) {
        hi = 1;
        const solLo = solveForTarget(+z);
        lo = Number.isFinite(solLo) ? solLo : 0;
      } else {
        const solLo = solveForTarget(+z);
        const solHi = solveForTarget(-z);
        lo = Number.isFinite(solLo) ? solLo : 0;
        hi = Number.isFinite(solHi) ? solHi : 1;
      }

      lo = clamp01(lo);
      hi = clamp01(hi);
      if (lo > hi) { const t = lo; lo = hi; hi = t; }
      return { lo, hi };
    }

    // Method labels used for display
    const METHOD_LABELS = {
      wilson: 'Wilson score',
      hypergeo: 'Hypergeometric score (finite-pop Wilson)',
      agresti: 'Agresti-Coull',
      wald: 'Wald (normal approx)'
    };

    // Calculate CI for a given method
    function calculateCI(method, x, n, N, z, fpc) {
      const p = x / n;
      const z2 = z * z;

      switch (method) {
        case 'wilson': {
          const denom = 1 + z2 / n;
          const center = (p + z2 / (2 * n)) / denom;
          const half = (z * Math.sqrt((p * (1 - p)) / n + z2 / (4 * n * n))) / denom;
          const se = Math.sqrt((p * (1 - p)) / n);
          return { lo: clamp01(center - half), hi: clamp01(center + half), se, pEst: p };
        }
        case 'hypergeo': {
          const hg = hypergeoScoreCI(x, n, N, z);
          const fVar = finitePopulationFactor(n, N);
          const se = Math.sqrt((p * (1 - p)) / n * fVar);
          return { lo: clamp01(hg.lo), hi: clamp01(hg.hi), se, pEst: p };
        }
        case 'agresti': {
          const nTilde = n + z2;
          const pTilde = (x + z2 / 2) / nTilde;
          const se = Math.sqrt((pTilde * (1 - pTilde)) / nTilde);
          return { lo: clamp01(pTilde - z * se), hi: clamp01(pTilde + z * se), se, pEst: pTilde };
        }
        default: { // wald
          const se = Math.sqrt((p * (1 - p)) / n) * fpc;
          return { lo: clamp01(p - z * se), hi: clamp01(p + z * se), se, pEst: p };
        }
      }
    }

    function renderSweepChart(canvasId, n, N, z, method, fpc, titleSuffix) {
      const labels = [];
      const lowerBounds = [];
      const upperBounds = [];
      const proportions = [];

      // Calculate for each x from 0 to n
      for (let xVal = 0; xVal <= n; xVal++) {
        labels.push(xVal);
        const ci = calculateCI(method, xVal, n, N, z, fpc);
        lowerBounds.push(ci.lo * n);
        upperBounds.push(ci.hi * n);
        proportions.push(xVal);
      }

      const ctx = document.getElementById(canvasId).getContext('2d');

      // Destroy existing chart if it exists
      if (sweepCharts[canvasId]) {
        sweepCharts[canvasId].destroy();
      }

      const shortLabels = { wilson: 'Wilson score', hypergeo: 'Hypergeometric score', agresti: 'Agresti-Coull', wald: 'Wald' };
      const methodLabel = shortLabels[method] || method;
      const title = titleSuffix
        ? `${methodLabel} CI bounds (n = ${n}, ${titleSuffix})`
        : `${methodLabel} CI bounds (n = ${n})`;

      sweepCharts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Upper bound',
              data: upperBounds,
              borderColor: '#fde725',
              backgroundColor: 'rgba(253, 231, 37, 0.2)',
              borderWidth: 2,
              fill: '+1',
              pointRadius: n <= 50 ? 2 : 0,
              pointHoverRadius: 4,
              tension: 0.1
            },
            {
              label: 'Successes (x)',
              data: proportions,
              borderColor: '#21918c',
              backgroundColor: 'rgba(68, 1, 84, 0.2)',
              borderWidth: 2,
              borderDash: [5, 5],
              fill: '+1',
              pointRadius: 0,
              pointHoverRadius: 4,
              tension: 0
            },
            {
              label: 'Lower bound',
              data: lowerBounds,
              borderColor: '#440154',
              backgroundColor: 'rgba(68, 1, 84, 0.15)',
              borderWidth: 2,
              fill: false,
              pointRadius: n <= 50 ? 2 : 0,
              pointHoverRadius: 4,
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            title: {
              display: true,
              text: title,
              font: { size: 14, weight: '600' },
              color: '#0f172a'
            },
            legend: {
              position: 'bottom',
              labels: {
                usePointStyle: true,
                padding: 16,
                font: { size: 12 }
              }
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  return `x = ${context[0].label}`;
                },
                label: function(context) {
                  return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Successes (x)',
                font: { size: 12, weight: '500' },
                color: '#475569'
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              },
              ticks: {
                maxTicksLimit: 10
              }
            },
            y: {
              title: {
                display: true,
                text: 'Count',
                font: { size: 12, weight: '500' },
                color: '#475569'
              },
              min: 0,
              max: n,
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            }
          }
        }
      });
    }

    function render3DSweepChart(containerId, n, z, method) {
      const container = document.getElementById(containerId);

      // Generate data grid: x from 0 to n, N from n to 10n
      const xValues = [];
      const nValues = [];
      const lowerSurface = [];
      const upperSurface = [];

      const xSteps = Math.min(n + 1, 51);  // Cap at 51 points for performance
      const nSteps = 20;  // 20 steps from n to 10n

      for (let i = 0; i < xSteps; i++) {
        const xVal = Math.round((i / (xSteps - 1)) * n);
        xValues.push(xVal);
      }

      for (let j = 0; j < nSteps; j++) {
        const nVal = Math.round(n + (j / (nSteps - 1)) * 9 * n);
        nValues.push(nVal);
      }

      // Calculate CI for each (x, N) combination
      for (let j = 0; j < nSteps; j++) {
        const lowerRow = [];
        const upperRow = [];
        const N = nValues[j];
        const fpc = finitePopulationCorrection(n, N);

        for (let i = 0; i < xSteps; i++) {
          const x = xValues[i];
          const ci = calculateCI(method, x, n, N, z, fpc);
          lowerRow.push(ci.lo * n);
          upperRow.push(ci.hi * n);
        }
        lowerSurface.push(lowerRow);
        upperSurface.push(upperRow);
      }

      // Create point estimate surface (the actual x values, constant across N)
      const pointEstimateSurface = [];
      for (let j = 0; j < nSteps; j++) {
        pointEstimateSurface.push([...xValues]);
      }

      const data = [
        {
          type: 'surface',
          x: xValues,
          y: nValues,
          z: upperSurface,
          name: 'Upper bound',
          colorscale: [[0, '#fde725'], [1, '#fde725']],
          showscale: false,
          opacity: 0.7,
          contours: {
            z: { show: true, usecolormap: false, highlightcolor: '#b8860b', width: 1 }
          }
        },
        {
          type: 'surface',
          x: xValues,
          y: nValues,
          z: pointEstimateSurface,
          name: 'Point estimate (x)',
          colorscale: [[0, '#21918c'], [1, '#21918c']],
          showscale: false,
          opacity: 0.5
        },
        {
          type: 'surface',
          x: xValues,
          y: nValues,
          z: lowerSurface,
          name: 'Lower bound',
          colorscale: [[0, '#a78bfa'], [1, '#a78bfa']],
          showscale: false,
          opacity: 0.7,
          contours: {
            z: { show: true, usecolormap: false, highlightcolor: '#7c3aed', width: 1 }
          }
        }
      ];

      const shortLabels = { wald: 'Wald', hypergeo: 'Hypergeometric score' };
      const layout = {
        title: {
          text: `${shortLabels[method]} CI bounds (n = ${n}, N: ${n} → ${10*n})`,
          font: { size: 14, family: '-apple-system, BlinkMacSystemFont, sans-serif' }
        },
        scene: {
          xaxis: { title: 'Successes (x)' },
          yaxis: { title: 'Population (N)' },
          zaxis: { title: 'Count', range: [0, n] },
          camera: { eye: { x: -1.5, y: -1.5, z: 1 } }
        },
        margin: { l: 10, r: 10, t: 50, b: 10 },
        showlegend: true,
        legend: { x: 0.01, y: 0.99, bgcolor: 'rgba(255,255,255,0.8)' },
        autosize: true
      };

      Plotly.newPlot(container, data, layout, { responsive: true });
    }

    function destroyAllSweepCharts() {
      Object.keys(sweepCharts).forEach(key => {
        if (sweepCharts[key]) {
          sweepCharts[key].destroy();
        }
      });
      sweepCharts = {};

      // Clean up Plotly charts
      document.querySelectorAll('.sweep-3d-chart-container').forEach(el => {
        Plotly.purge(el);
      });
    }

    function switchSweepTab(index) {
      activeTabIndex = index;
      document.querySelectorAll('.sweep-tab').forEach((tab, i) => {
        tab.classList.toggle('active', i === index);
      });
      document.querySelectorAll('.sweep-tab-panel').forEach((panel, i) => {
        panel.classList.toggle('active', i === index);
      });
    }

    // Get tab configurations for sweep mode based on method
    function getSweepTabConfigs(n, method) {
      const nMultiples = [
        { label: 'N = n', mult: 1 },
        { label: 'N = 4n', mult: 4 },
        { label: 'N = 100n', mult: 100 }
      ];

      if (method === 'wald') {
        return [
          { label: 'No FPC', N: null, useFpc: false, is3D: false },
          ...nMultiples.map(m => ({ label: m.label, N: m.mult * n, useFpc: true, is3D: false })),
          { label: '3D N-Sweep', is3D: true, useFpc: true }
        ];
      }
      if (method === 'hypergeo') {
        return [
          ...nMultiples.map(m => ({ label: m.label, N: m.mult * n, useFpc: true, is3D: false })),
          { label: '3D N-Sweep', is3D: true, useFpc: true }
        ];
      }
      // Wilson and Agresti-Coull: single chart, no tabs
      return [{ label: null, N: null, useFpc: false, is3D: false }];
    }

    function renderSweepTabs(n, z, method) {
      destroyAllSweepCharts();

      const tabsContainer = document.getElementById('sweep-tabs');
      const panelsContainer = document.getElementById('sweep-panels');
      const tabConfigs = getSweepTabConfigs(n, method);

      // Default to "N = n" tab if available, otherwise first tab
      const nEqualsNIndex = tabConfigs.findIndex(config => config.label === 'N = n');
      const activeIdx = nEqualsNIndex >= 0 ? nEqualsNIndex : 0;

      // Build tabs HTML (only show if multiple tabs)
      const showTabs = tabConfigs.length > 1;
      tabsContainer.style.display = showTabs ? 'flex' : 'none';
      tabsContainer.innerHTML = showTabs
        ? tabConfigs.map((config, i) =>
            `<button class="pill-btn sweep-tab${i === activeIdx ? ' active' : ''}" onclick="switchSweepTab(${i})">${config.label}</button>`
          ).join('')
        : '';

      // Build panels HTML (different container for 3D vs 2D charts)
      panelsContainer.innerHTML = tabConfigs.map((config, i) =>
        config.is3D
          ? `<div class="sweep-tab-panel${i === activeIdx ? ' active' : ''}" id="sweep-panel-${i}">
              <div class="sweep-3d-chart-container" id="sweep-3d-chart-${i}"></div>
            </div>`
          : `<div class="sweep-tab-panel${i === activeIdx ? ' active' : ''}" id="sweep-panel-${i}">
              <div class="sweep-chart-container">
                <canvas id="sweep-chart-${i}"></canvas>
              </div>
            </div>`
      ).join('');

      // Render all charts
      tabConfigs.forEach((config, i) => {
        if (config.is3D) {
          render3DSweepChart(`sweep-3d-chart-${i}`, n, z, method);
        } else {
          const effectiveN = config.N || n;
          const fpc = config.useFpc ? finitePopulationCorrection(n, effectiveN) : 1;
          const titleSuffix = config.useFpc ? `N = ${effectiveN}` : (method === 'wald' ? 'no FPC' : '');
          renderSweepChart(`sweep-chart-${i}`, n, effectiveN, z, method, fpc, titleSuffix);
        }
      });

      activeTabIndex = activeIdx;
    }

    function setMode(newMode) {
      mode = newMode;
      document.getElementById('mode-successes').classList.toggle('active', mode === 'successes');
      document.getElementById('mode-proportion').classList.toggle('active', mode === 'proportion');
      document.getElementById('mode-sweep').classList.toggle('active', mode === 'sweep');
      document.getElementById('successes-field').style.display = mode === 'successes' ? 'block' : 'none';
      document.getElementById('proportion-field').style.display = mode === 'proportion' ? 'block' : 'none';
      document.querySelector('.fpc-box').style.display = mode === 'sweep' ? 'none' : 'flex';
      calculate();
    }

    function setConf(c) {
      document.getElementById('input-conf').value = String(c);
      calculate();
    }

    function calculate() {
      const nStr = document.getElementById('input-n').value;
      const confStr = document.getElementById('input-conf').value;
      const NStr = document.getElementById('input-N').value;
      const method = document.getElementById('input-method').value;
      const useFpc = document.getElementById('input-fpc').checked;

      const n = Number(nStr);
      const conf = Number(confStr);
      const N = Number(NStr);

      const alpha = 1 - conf;
      const z = normInv(1 - alpha / 2);

      const needsN = useFpc || method === 'hypergeo';
      const fpc = useFpc ? finitePopulationCorrection(n, N) : 1;

      // Update UI for N field
      const showNInput = useFpc || method === 'hypergeo';
      document.getElementById('pop-field').classList.toggle('disabled', !showNInput);
      document.getElementById('input-N').disabled = !showNInput;

      const warningEl = document.getElementById('warning');
      const resultsEl = document.getElementById('results');
      const placeholderEl = document.getElementById('results-placeholder');
      const sweepResultsEl = document.getElementById('sweep-results');

      // Handle sweep mode
      if (mode === 'sweep') {
        // For sweep mode, we only need n, conf, and z to be valid
        // N values are computed based on the method
        const sweepOk = Number.isFinite(n) && n > 0 && Number.isInteger(n) &&
                        Number.isFinite(conf) && conf > 0 && conf < 1 &&
                        Number.isFinite(z);

        if (!sweepOk) {
          warningEl.style.display = 'block';
          warningEl.textContent = 'Please enter valid inputs: n > 0 (integer), confidence between 0 and 1.';
          resultsEl.style.display = 'none';
          sweepResultsEl.style.display = 'none';
          placeholderEl.style.display = 'block';
          return;
        }

        warningEl.style.display = 'none';
        placeholderEl.style.display = 'none';
        resultsEl.style.display = 'none';
        sweepResultsEl.style.display = 'block';

        renderSweepTabs(n, z, method);
        return;
      }

      // Regular modes (successes or proportion)
      let x = null, p = null;

      if (mode === 'successes') {
        x = Number(document.getElementById('input-x').value);
        if (Number.isFinite(x) && Number.isFinite(n) && n > 0) p = x / n;
      } else {
        p = Number(document.getElementById('input-p').value);
        if (Number.isFinite(p) && Number.isFinite(n) && n > 0) x = p * n;
      }

      const ok = Number.isFinite(n) && n > 0 &&
                 Number.isFinite(conf) && conf > 0 && conf < 1 &&
                 p !== null && Number.isFinite(p) && p >= 0 && p <= 1 &&
                 x !== null && Number.isFinite(x) && x >= 0 && x <= n &&
                 Number.isFinite(z) &&
                 (!needsN || (Number.isFinite(N) && N >= n && N > 1 && Number.isFinite(fpc)));

      if (!ok) {
        warningEl.style.display = 'block';
        warningEl.textContent = `Please enter valid inputs: n > 0, confidence between 0 and 1, and p in [0,1] (or successes x between 0 and n).${needsN ? ' Also ensure N ≥ n and N > 1.' : ''}`;
        resultsEl.style.display = 'none';
        sweepResultsEl.style.display = 'none';
        placeholderEl.style.display = 'block';
        return;
      }

      warningEl.style.display = 'none';
      placeholderEl.style.display = 'none';
      sweepResultsEl.style.display = 'none';
      resultsEl.style.display = 'grid';

      // Calculate all intervals using centralized function
      const allMethods = ['wilson', 'hypergeo', 'agresti', 'wald'];
      const results = {};
      allMethods.forEach(m => {
        const methodFpc = (m === 'wald' && useFpc) ? fpc : 1;
        results[m] = calculateCI(m, x, n, N, z, methodFpc);
      });

      const chosen = results[method];
      const rse = chosen.pEst > 0 ? chosen.se / chosen.pEst : NaN;

      // Update main result display
      document.getElementById('chosen-method').textContent = METHOD_LABELS[method];
      document.getElementById('chosen-lo-count').textContent = fmtCount(chosen.lo * n, 0);
      document.getElementById('chosen-lo-pct').textContent = fmtPct(chosen.lo);
      document.getElementById('chosen-hi-count').textContent = fmtCount(chosen.hi * n, 0);
      document.getElementById('chosen-hi-pct').textContent = fmtPct(chosen.hi);
      document.getElementById('chosen-width').textContent = fmtPct(chosen.hi - chosen.lo);
      document.getElementById('chosen-rse').textContent = fmtPct(rse);

      // Update details section
      document.getElementById('detail-n').textContent = n;
      document.getElementById('detail-x').textContent = fmtCount(x, 0);
      document.getElementById('detail-z').textContent = fmtNum(z, 6);

      const modelText = method === 'hypergeo' ? 'Finite-pop (Hypergeometric score)'
        : useFpc ? 'Finite-pop (Wald+FPC)'
        : 'Binomial (default)';
      document.getElementById('detail-model').textContent = modelText;

      if (needsN) {
        const factor = method === 'hypergeo' ? finitePopulationFactor(n, N) : fpc;
        document.getElementById('detail-note').textContent = `N = ${N} · factor = ${fmtNum(factor, 6)}`;
      } else {
        document.getElementById('detail-note').textContent = 'Population size not used';
      }

      // Update method comparison rows
      allMethods.forEach(m => {
        const row = document.getElementById('row-' + m);
        const val = document.getElementById('val-' + m);
        const r = results[m];
        row.classList.toggle('active', m === method);
        val.textContent = `${fmtCount(r.lo * n, 0)} → ${fmtCount(r.hi * n, 0)} · ${fmtPct(r.lo)} → ${fmtPct(r.hi)}`;
      });
    }

    // Initial calculation
    calculate();
  </script>
</body>
</html>

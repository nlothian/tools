<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM API Comparator</title>
    <script src="https://cdn.jsdelivr.net/npm/gpt-tokenizer@3.4.0/dist/o200k_base.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            color: #2d3748;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2em;
        }

        .api-selection {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 8px;
        }

        .provider-section {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
        }

        .provider-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .provider-header input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .provider-header label {
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            color: #2d3748;
        }

        .model-options {
            display: none;
            margin-left: 30px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e2e8f0;
        }

        .model-options.active {
            display: block;
        }

        .model-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
        }

        .model-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .model-checkbox label {
            cursor: pointer;
            font-weight: 400;
            color: #4a5568;
        }

        .custom-model-input {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .custom-model-input input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 14px;
        }

        .custom-model-input input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-section {
            margin-bottom: 25px;
        }

        /* Conversation Rounds Styles */
        .conversation-round {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .conversation-round-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .conversation-round-select {
            padding: 6px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }

        .conversation-round-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .delete-round-button {
            background: #fc8181;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .delete-round-button:hover {
            background: #f56565;
        }

        .conversation-round-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .input-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2d3748;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        #systemPrompt {
            min-height: 100px;
        }



        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        }

        button {
            flex: 1;
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        #sendButton {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #sendButton:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        #sendButton:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #clearKeysButton {
            background: #fc8181;
            color: white;
        }

        #clearKeysButton:hover {
            background: #f56565;
            transform: translateY(-2px);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .result-card {
            background: #f7fafc;
            border-radius: 8px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }

        .result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        .result-title {
            font-weight: 700;
            font-size: 18px;
            color: #2d3748;
        }

        .result-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-loading {
            background: #fef5e7;
            color: #d69e2e;
        }

        .status-success {
            background: #d4edda;
            color: #38a169;
        }

        .status-error {
            background: #f8d7da;
            color: #e53e3e;
        }

        .result-content {
            color: #4a5568;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .token-info {
            margin-top: 15px;
            padding: 12px;
            background: #edf2f7;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }

        .token-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .token-label {
            font-weight: 600;
            color: #2d3748;
        }

        .token-value {
            color: #4a5568;
        }

        .price-unknown {
            color: #d69e2e;
            font-style: italic;
        }

        .total-price {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 2px solid #cbd5e0;
            font-weight: 700;
            color: #2d3748;
        }

        .error-message {
            color: #e53e3e;
            font-weight: 500;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ¤– LLM API Comparator</h1>
        
        <div class="api-selection">
            <div class="provider-section">
                <div class="provider-header">
                    <input type="checkbox" id="openai-provider" class="provider-checkbox" data-provider="openai">
                    <label for="openai-provider">OpenAI</label>
                </div>
                <div class="model-options" id="openai-models">
                    <div class="model-checkbox">
                        <input type="checkbox" id="openai-gpt5nano" data-provider="openai" data-model="gpt-5-nano">
                        <label for="openai-gpt5nano">gpt-5-nano</label>
                    </div>
                    <div class="custom-model-input">
                        <input type="text" id="openai-custom" placeholder="Custom model name..." data-provider="openai">
                    </div>
                </div>
            </div>

            <div class="provider-section">
                <div class="provider-header">
                    <input type="checkbox" id="anthropic-provider" class="provider-checkbox" data-provider="anthropic">
                    <label for="anthropic-provider">Anthropic</label>
                </div>
                <div class="model-options" id="anthropic-models">
                    <div class="model-checkbox">
                        <input type="checkbox" id="anthropic-haiku3" data-provider="anthropic" data-model="claude-3-haiku-20240307">
                        <label for="anthropic-haiku3">claude-3-haiku</label>
                    </div>
                    <div class="model-checkbox">
                        <input type="checkbox" id="anthropic-haiku35" data-provider="anthropic" data-model="claude-3-5-haiku-20241022">
                        <label for="anthropic-haiku35">claude-3.5-haiku</label>
                    </div>
                    <div class="model-checkbox">
                        <input type="checkbox" id="anthropic-haiku45" data-provider="anthropic" data-model="claude-haiku-4-5-20251001">
                        <label for="anthropic-haiku45">claude-4.5-haiku</label>
                    </div>
                    <div class="custom-model-input">
                        <input type="text" id="anthropic-custom" placeholder="Custom model name..." data-provider="anthropic">
                    </div>
                </div>
            </div>

            <div class="provider-section">
                <div class="provider-header">
                    <input type="checkbox" id="gemini-provider" class="provider-checkbox" data-provider="gemini">
                    <label for="gemini-provider">Google Gemini</label>
                </div>
                <div class="model-options" id="gemini-models">
                    <div class="model-checkbox">
                        <input type="checkbox" id="gemini-flash" data-provider="gemini" data-model="gemini-2.5-flash-lite">
                        <label for="gemini-flash">gemini-2.5-flash-lite</label>
                    </div>
                    <div class="custom-model-input">
                        <input type="text" id="gemini-custom" placeholder="Custom model name..." data-provider="gemini">
                    </div>
                </div>
            </div>

            <div class="provider-section">
                <div class="provider-header">
                    <input type="checkbox" id="openrouter-provider" class="provider-checkbox" data-provider="openrouter">
                    <label for="openrouter-provider">OpenRouter</label>
                </div>
                <div class="model-options" id="openrouter-models">
                    <div class="custom-model-input">
                        <input type="text" id="openrouter-custom" placeholder="Model name (e.g., openai/gpt-3.5-turbo)..." data-provider="openrouter">
                    </div>
                </div>
            </div>
        </div>

        <div class="input-section">
            <label for="systemPrompt">System Prompt:</label>
            <textarea id="systemPrompt" placeholder="Enter your system prompt here...">You are a helpful assistant.</textarea>
        </div>

        <!-- Conversation Rounds Section -->
        <div class="input-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label>Conversation Rounds:</label>
                <button id="addConversationRound" style="
                    padding: 6px 12px;
                    background: #667eea;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 600;
                ">+ Add Round</button>
            </div>
            <div id="conversationRoundsContainer" style="display: flex; flex-direction: column; gap: 12px;"></div>
        </div>

        <div class="button-group">
            <button id="sendButton">Send to Selected APIs</button>
            <button id="clearKeysButton">Clear Saved API Keys</button>
        </div>

        <div class="results-grid" id="resultsGrid"></div>
    </div>

    <script>
        const API_CONFIGS = {
            openai: {
                name: 'OpenAI',
                storageKey: 'openai_api_key',
                endpoint: 'https://api.openai.com/v1/chat/completions'
            },
            anthropic: {
                name: 'Anthropic',
                storageKey: 'anthropic_api_key',
                endpoint: 'https://api.anthropic.com/v1/messages'
            },
            gemini: {
                name: 'Gemini',
                storageKey: 'gemini_api_key',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/models'
            },
            openrouter: {
                name: 'OpenRouter',
                storageKey: 'openrouter_api_key',
                endpoint: 'https://openrouter.ai/api/v1/chat/completions'
            }
        };

        // Pricing data cache
        let pricingData = [];

        // Fetch pricing data
        async function fetchPricingData() {
            try {
                const response = await fetch('https://www.llm-prices.com/current-v1.json');
                const data = await response.json();
                pricingData = data.prices || [];
                console.log('Pricing data loaded:', pricingData.length, 'models');
            } catch (error) {
                console.error('Failed to load pricing data:', error);
                pricingData = [];
            }
        }

        // Count tokens using gpt-tokenizer
        function countTokens(text) {
            try {
                const encoded = GPTTokenizer_o200k_base.encode(text);
                return encoded.length;
            } catch (error) {
                console.error('Token counting error:', error);
                return 0;
            }
        }

        // Get pricing for a model
        function getModelPricing(provider, modelName) {
            if (!pricingData || !Array.isArray(pricingData) || pricingData.length === 0) return null;

            // Normalize model name for matching
            const normalizedModel = modelName.toLowerCase();
            
            // Search through pricing data
            for (const item of pricingData) {
                const itemModel = (item.id || '').toLowerCase();
                const itemVendor = (item.vendor || '').toLowerCase();
                
                // Check if model matches
                if (itemModel.includes(normalizedModel) || normalizedModel.includes(itemModel)) {
                    // For some providers, also check vendor name
                    if (provider === 'anthropic' && itemVendor === 'anthropic') {
                        return item;
                    } else if (provider === 'openai' && itemVendor === 'openai') {
                        return item;
                    } else if (provider === 'gemini' && itemVendor === 'google') {
                        return item;
                    } else if (provider === 'openrouter') {
                        // OpenRouter can use any model, so just match on model name
                        return item;
                    }
                }
            }
            
            return null;
        }

        // Calculate and format pricing
        function calculatePricing(provider, model, inputTokens, outputTokens) {
            const pricing = getModelPricing(provider, model);
            
            if (!pricing) {
                return {
                    inputPrice: 'Unknown',
                    outputPrice: 'Unknown',
                    totalPrice: 'Unknown',
                    isUnknown: true
                };
            }

            // Pricing is typically per million tokens
            const inputPrice = (inputTokens / 1000000) * (pricing.input || 0);
            const outputPrice = (outputTokens / 1000000) * (pricing.output || 0);
            const totalPrice = inputPrice + outputPrice;

            return {
                inputPrice: `$${inputPrice.toFixed(6)}`,
                outputPrice: `$${outputPrice.toFixed(6)}`,
                totalPrice: `$${totalPrice.toFixed(6)}`,
                isUnknown: false
            };
        }

        // Load pricing data on page load
        fetchPricingData();

        // Load saved prompts and conversation rounds on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedSystemPrompt = localStorage.getItem('saved_system_prompt');
            const savedConversationRounds = localStorage.getItem('saved_conversation_rounds');
            
            if (savedSystemPrompt) {
                document.getElementById('systemPrompt').value = savedSystemPrompt;
            }
            
            // Load saved conversation rounds
            if (savedConversationRounds) {
                try {
                    const rounds = JSON.parse(savedConversationRounds);
                    if (Array.isArray(rounds)) {
                        rounds.forEach(round => {
                            addConversationRound(round.role, round.message, false);
                        });
                    }
                } catch (error) {
                    console.error('Failed to parse conversation rounds:', error);
                }
            }
        });

        // Function to create a conversation round element
        function createConversationRoundElement(roundId, role, message) {
            const roundElement = document.createElement('div');
            roundElement.className = 'conversation-round';
            roundElement.dataset.roundId = roundId;
            
            roundElement.innerHTML = `
                <div class="conversation-round-header">
                    <select class="conversation-round-select" data-round-id="${roundId}">
                        <option value="user" ${role === 'user' ? 'selected' : ''}>User</option>
                        <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>Assistant</option>
                    </select>
                    <button class="delete-round-button" data-round-id="${roundId}">Delete</button>
                </div>
                <textarea class="conversation-round-textarea" placeholder="Enter message content..." data-round-id="${roundId}">${message || ''}</textarea>
            `;
            
            return roundElement;
        }

        // Function to add a conversation round
        function addConversationRound(role = 'user', message = '', saveToStorage = true) {
            const container = document.getElementById('conversationRoundsContainer');
            const roundId = 'round-' + Date.now();
            
            const roundElement = createConversationRoundElement(roundId, role, message);
            container.appendChild(roundElement);
            
            // Add event listeners for the new elements
            const selectElement = roundElement.querySelector('.conversation-round-select');
            const deleteButton = roundElement.querySelector('.delete-round-button');
            const textareaElement = roundElement.querySelector('.conversation-round-textarea');
            
            selectElement.addEventListener('change', saveConversationRounds);
            textareaElement.addEventListener('input', saveConversationRounds);
            deleteButton.addEventListener('click', () => {
                roundElement.remove();
                saveConversationRounds();
            });
            
            if (saveToStorage) {
                saveConversationRounds();
            }
        }

        // Function to save conversation rounds to local storage
        function saveConversationRounds() {
            const rounds = [];
            const roundElements = document.querySelectorAll('.conversation-round');
            
            roundElements.forEach(element => {
                const select = element.querySelector('.conversation-round-select');
                const textarea = element.querySelector('.conversation-round-textarea');
                
                rounds.push({
                    role: select.value,
                    message: textarea.value
                });
            });
            
            localStorage.setItem('saved_conversation_rounds', JSON.stringify(rounds));
        }

        // Save prompts as user types
        document.getElementById('systemPrompt').addEventListener('input', (e) => {
            localStorage.setItem('saved_system_prompt', e.target.value);
        });

        function getApiKey(provider) {
            let apiKey = localStorage.getItem(API_CONFIGS[provider].storageKey);
            
            if (!apiKey) {
                apiKey = window.prompt(`Enter your ${API_CONFIGS[provider].name} API key:`);
                if (apiKey) {
                    localStorage.setItem(API_CONFIGS[provider].storageKey, apiKey);
                }
            }
            
            return apiKey;
        }

        function createResultCard(provider, model) {
            const cardId = `result-${provider}-${model.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const card = document.createElement('div');
            card.className = 'result-card';
            card.id = cardId;
            card.innerHTML = `
                <div class="result-header">
                    <div class="result-title">${API_CONFIGS[provider].name}<br><small style="font-size: 12px; color: #718096;">${model}</small></div>
                    <div class="result-status status-loading">Loading...</div>
                </div>
                <div class="result-content">
                    <div class="loading"></div>
                </div>
            `;
            return card;
        }

        function updateResultCard(provider, model, status, content, inputText = '', outputText = '') {
            const cardId = `result-${provider}-${model.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const card = document.getElementById(cardId);
            const statusEl = card.querySelector('.result-status');
            const contentEl = card.querySelector('.result-content');
            
            statusEl.className = `result-status status-${status}`;
            statusEl.textContent = status === 'success' ? 'Success' : 'Error';
            
            if (status === 'success' && inputText && outputText) {
                // Count tokens
                const inputTokens = countTokens(inputText);
                const outputTokens = countTokens(outputText);
                
                // Calculate pricing
                const pricing = calculatePricing(provider, model, inputTokens, outputTokens);
                
                // Build pricing display
                const priceClass = pricing.isUnknown ? 'price-unknown' : '';
                const tokenInfoHTML = `
                    <div class="token-info">
                        <div class="token-row">
                            <span class="token-label">Input Tokens:</span>
                            <span class="token-value">${inputTokens.toLocaleString()}</span>
                        </div>
                        <div class="token-row">
                            <span class="token-label">Input Price:</span>
                            <span class="token-value ${priceClass}">${pricing.inputPrice}</span>
                        </div>
                        <div class="token-row">
                            <span class="token-label">Output Tokens:</span>
                            <span class="token-value">${outputTokens.toLocaleString()}</span>
                        </div>
                        <div class="token-row">
                            <span class="token-label">Output Price:</span>
                            <span class="token-value ${priceClass}">${pricing.outputPrice}</span>
                        </div>
                        <div class="token-row total-price">
                            <span class="token-label">Total Price:</span>
                            <span class="token-value ${priceClass}">${pricing.totalPrice}</span>
                        </div>
                    </div>
                `;
                
                contentEl.innerHTML = content + tokenInfoHTML;
            } else {
                contentEl.innerHTML = content;
            }
        }

        async function callOpenAI(systemPrompt, apiKey, model) {
            // Build messages array with conversation rounds
            const messages = [];
            
            // Add system prompt first
            if (systemPrompt.trim()) {
                messages.push({ role: 'system', content: systemPrompt });
            }
            
            // Add conversation rounds
            const roundElements = document.querySelectorAll('.conversation-round');
            roundElements.forEach(element => {
                const select = element.querySelector('.conversation-round-select');
                const textarea = element.querySelector('.conversation-round-textarea');
                
                if (textarea.value.trim()) {
                    messages.push({ role: select.value, content: textarea.value });
                }
            });

            const response = await fetch(API_CONFIGS.openai.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        async function callAnthropic(systemPrompt, apiKey, model) {
            // Build messages array with conversation rounds
            const messages = [];
            
            // Add conversation rounds
            const roundElements = document.querySelectorAll('.conversation-round');
            roundElements.forEach(element => {
                const select = element.querySelector('.conversation-round-select');
                const textarea = element.querySelector('.conversation-round-textarea');
                
                if (textarea.value.trim()) {
                    messages.push({ role: select.value, content: textarea.value });
                }
            });

            const response = await fetch(API_CONFIGS.anthropic.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: model,
                    max_tokens: 1000,
                    system: systemPrompt,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.content[0].text;
        }

        async function callGemini(systemPrompt, apiKey, model) {
            // Build conversation history
            let conversationText = systemPrompt;
            
            // Add conversation rounds
            const roundElements = document.querySelectorAll('.conversation-round');
            roundElements.forEach(element => {
                const select = element.querySelector('.conversation-round-select');
                const textarea = element.querySelector('.conversation-round-textarea');
                
                if (textarea.value.trim()) {
                    conversationText += `\n\n${select.value.toUpperCase()}: ${textarea.value}`;
                }
            });

            const response = await fetch(`${API_CONFIGS.gemini.endpoint}/${model}:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: conversationText
                        }]
                    }]
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        async function callOpenRouter(systemPrompt, apiKey, model) {
            // Build messages array with conversation rounds
            const messages = [];
            
            // Add system prompt first
            if (systemPrompt.trim()) {
                messages.push({ role: 'system', content: systemPrompt });
            }
            
            // Add conversation rounds
            const roundElements = document.querySelectorAll('.conversation-round');
            roundElements.forEach(element => {
                const select = element.querySelector('.conversation-round-select');
                const textarea = element.querySelector('.conversation-round-textarea');
                
                if (textarea.value.trim()) {
                    messages.push({ role: select.value, content: textarea.value });
                }
            });

            const response = await fetch(API_CONFIGS.openrouter.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'HTTP-Referer': window.location.href,
                    'X-Title': 'LLM Comparator'
                },
                body: JSON.stringify({
                    model: model,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        async function callAPI(provider, model, systemPrompt, apiKey) {
            if (!apiKey) {
                throw new Error('API key not provided');
            }

            switch (provider) {
                case 'openai':
                    return await callOpenAI(systemPrompt, apiKey, model);
                case 'anthropic':
                    return await callAnthropic(systemPrompt, apiKey, model);
                case 'gemini':
                    return await callGemini(systemPrompt, apiKey, model);
                case 'openrouter':
                    return await callOpenRouter(systemPrompt, apiKey, model);
                default:
                    throw new Error('Unknown API');
            }
        }

        // Add conversation round button handler
        document.getElementById('addConversationRound').addEventListener('click', () => {
            addConversationRound();
        });

        // Provider checkbox toggle handler
        document.querySelectorAll('.provider-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const provider = this.dataset.provider;
                const modelOptions = document.getElementById(`${provider}-models`);
                if (this.checked) {
                    modelOptions.classList.add('active');
                } else {
                    modelOptions.classList.remove('active');
                }
            });
        });

        function getSelectedModels() {
            const selections = [];
            
            document.querySelectorAll('.provider-checkbox:checked').forEach(providerCheckbox => {
                const provider = providerCheckbox.dataset.provider;
                
                // Get checked model checkboxes
                const modelCheckboxes = document.querySelectorAll(`input[type="checkbox"][data-provider="${provider}"][data-model]`);
                modelCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        selections.push({
                            provider: provider,
                            model: checkbox.dataset.model
                        });
                    }
                });
                
                // Get custom model input
                const customInput = document.getElementById(`${provider}-custom`);
                if (customInput && customInput.value.trim()) {
                    selections.push({
                        provider: provider,
                        model: customInput.value.trim()
                    });
                }
            });
            
            return selections;
        }

        document.getElementById('sendButton').addEventListener('click', async () => {
            const selections = getSelectedModels();

            if (selections.length === 0) {
                alert('Please select at least one provider and model');
                return;
            }

            const systemPrompt = document.getElementById('systemPrompt').value;
            
            // Check that conversation rounds have content
            const roundElements = document.querySelectorAll('.conversation-round');
            const hasConversationContent = Array.from(roundElements).some(el => 
                el.querySelector('.conversation-round-textarea').value.trim()
            );
            
            if (!hasConversationContent) {
                alert('Please add at least one conversation round');
                return;
            }

            // Get unique providers that need API keys
            const uniqueProviders = [...new Set(selections.map(s => s.provider))];
            
            // Prompt for API keys upfront for all providers
            const apiKeys = {};
            for (const provider of uniqueProviders) {
                const key = getApiKey(provider);
                if (!key) {
                    alert(`API key required for ${API_CONFIGS[provider].name}`);
                    return;
                }
                apiKeys[provider] = key;
            }

            const resultsGrid = document.getElementById('resultsGrid');
            resultsGrid.innerHTML = '';

            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;

            // Combined input text for token counting
            let inputText = systemPrompt;
            roundElements.forEach(el => {
                const content = el.querySelector('.conversation-round-textarea').value;
                if (content.trim()) {
                    inputText += '\n\n' + content;
                }
            });

            // Create result cards for all selections
            selections.forEach(selection => {
                const card = createResultCard(selection.provider, selection.model);
                resultsGrid.appendChild(card);
            });

            // Call all APIs concurrently
            const apiPromises = selections.map(selection =>
                callAPI(selection.provider, selection.model, systemPrompt, apiKeys[selection.provider])
                    .then(result => {
                        updateResultCard(selection.provider, selection.model, 'success', result, inputText, result);
                    })
                    .catch(error => {
                        updateResultCard(selection.provider, selection.model, 'error', 
                            `<span class="error-message">Error: ${error.message}</span>`);
                    })
            );

            await Promise.all(apiPromises);

            sendButton.disabled = false;
        });

        document.getElementById('clearKeysButton').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved API keys?')) {
                Object.values(API_CONFIGS).forEach(config => {
                    localStorage.removeItem(config.storageKey);
                });
                alert('All API keys have been cleared');
            }
        });
    </script>
</body>
</html>

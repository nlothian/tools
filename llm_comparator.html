<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM API Comparator</title>
    <script src="https://cdn.jsdelivr.net/npm/gpt-tokenizer@3.4.0/dist/o200k_base.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script type="module">
      import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
      window.marked = marked;
    </script>
    <script type="module">
      import { Octokit } from "https://esm.sh/@octokit/core";
      window.Octokit = Octokit;
    </script>
    <style type="text/tailwindcss">
        @theme {
            /* Amber Terminal Color Palette */
            --color-terminal-bg: #0a0a08;
            --color-terminal-text: #ffb000;
            --color-terminal-text-deep: #ff8c00;
            --color-terminal-muted: #664400;
            --color-terminal-dim: #996600;
            --color-terminal-error: #ff6600;
            --color-terminal-success: #ddaa00;
            --color-terminal-green: #00ff00;

            /* Typography */
            --font-family-mono: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Courier New', monospace;
            --line-height-terminal: 1.6;

            /* Effects */
            --glow-sm: 0 0 5px rgb(255 176 0 / 0.5);
            --glow-md: 0 0 10px rgb(255 176 0 / 0.4);
            --glow-lg: 0 0 20px rgb(255 176 0 / 0.3);

            /* Screen curvature */
            --radius-screen: 8px;
        }

        @layer base {
            body {
                @apply bg-terminal-bg text-terminal-text font-mono antialiased;
                line-height: 1.6;
            }
        }

        @layer utilities {
            .text-glow {
                text-shadow: var(--glow-sm), var(--glow-md);
            }

            .text-glow-strong {
                text-shadow:
                    0 0 5px rgb(255 176 0 / 0.8),
                    0 0 10px rgb(255 176 0 / 0.4),
                    0 0 15px rgb(255 176 0 / 0.2);
            }

            .box-glow {
                box-shadow: var(--glow-lg), inset 0 0 100px rgb(255 176 0 / 0.02);
            }

            /* CRT Screen effect */
            .crt-screen {
                @apply border-2 border-terminal-text;
                border-radius: var(--radius-screen);
                box-shadow: var(--glow-lg), inset 0 0 100px rgb(255 176 0 / 0.02);
                position: relative;
            }

            /* Scanlines overlay */
            .scanlines::before {
                content: '';
                position: absolute;
                inset: 0;
                background: repeating-linear-gradient(
                    0deg,
                    rgb(0 0 0 / 0.15),
                    rgb(0 0 0 / 0.15) 1px,
                    transparent 1px,
                    transparent 2px
                );
                pointer-events: none;
                z-index: 10;
                border-radius: var(--radius-screen);
            }

            /* Terminal box borders */
            .terminal-box {
                @apply border border-terminal-text p-4 relative;
                background: rgb(255 176 0 / 0.02);
            }

            /* Box title positioned on border */
            .terminal-box-title {
                @apply absolute -top-2.5 left-4 bg-terminal-bg px-2 text-xs text-terminal-text-deep uppercase tracking-wider;
            }

            /* Border highlight on left */
            .border-l-highlight {
                @apply border-l-2 border-terminal-muted transition-colors duration-100;
            }

            .border-l-highlight:hover {
                @apply border-terminal-text;
                background: rgb(255 176 0 / 0.05);
            }

            .border-l-highlight.active {
                @apply border-terminal-text-deep;
                background: rgb(255 176 0 / 0.08);
            }

            /* Terminal buttons */
            .terminal-btn {
                @apply bg-transparent border border-terminal-text text-terminal-text
                       px-3 py-1.5 text-[11px] uppercase tracking-wider cursor-pointer
                       transition-all duration-100;
            }

            .terminal-btn:hover {
                background: rgb(255 176 0 / 0.2);
                box-shadow: 0 0 10px rgb(255 176 0 / 0.3);
            }

            .terminal-btn-primary {
                @apply bg-terminal-muted border border-terminal-text-deep text-terminal-text
                       px-3 py-1.5 text-[11px] uppercase tracking-wider cursor-pointer
                       transition-all duration-100;
            }

            .terminal-btn-primary:hover {
                background: rgb(255 140 0 / 0.3);
                box-shadow: 0 0 10px rgb(255 176 0 / 0.3);
            }

            .terminal-btn-danger {
                @apply bg-transparent border border-terminal-error text-terminal-error
                       px-3 py-1.5 text-[11px] uppercase tracking-wider cursor-pointer
                       transition-all duration-100;
            }

            .terminal-btn-danger:hover {
                background: rgb(255 102 0 / 0.2);
                box-shadow: 0 0 10px rgb(255 102 0 / 0.3);
            }

            .terminal-btn-success {
                @apply bg-transparent border border-terminal-success text-terminal-success
                       px-3 py-1.5 text-[11px] uppercase tracking-wider cursor-pointer
                       transition-all duration-100;
            }

            .terminal-btn-success:hover {
                background: rgb(221 170 0 / 0.2);
                box-shadow: 0 0 10px rgb(221 170 0 / 0.3);
            }

            /* Terminal inputs */
            .terminal-input {
                @apply w-full bg-terminal-bg border border-terminal-muted border-l-[3px]
                       border-l-terminal-text text-terminal-text px-3 py-2 text-[12px]
                       outline-none;
            }

            .terminal-input:focus {
                @apply border-l-terminal-text-deep;
                background: rgb(255 176 0 / 0.05);
                box-shadow: 0 0 5px rgb(255 176 0 / 0.2);
            }

            .terminal-input::placeholder {
                @apply text-terminal-muted;
            }

            /* Terminal checkbox */
            .terminal-checkbox {
                appearance: none;
                width: 16px;
                height: 16px;
                border: 1px solid var(--color-terminal-text);
                background: var(--color-terminal-bg);
                cursor: pointer;
                position: relative;
                flex-shrink: 0;
            }

            .terminal-checkbox:checked::before {
                content: 'X';
                position: absolute;
                top: -2px;
                left: 3px;
                color: var(--color-terminal-text-deep);
                font-size: 12px;
            }

            /* Cursor blink animation */
            @keyframes blink {
                0%, 50% { opacity: 1; }
                51%, 100% { opacity: 0; }
            }

            .cursor-blink {
                animation: blink 1s linear infinite;
            }

            /* Terminal prose styling for markdown */
            .prose {
                color: var(--color-terminal-text);
            }
            .prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 {
                color: var(--color-terminal-text-deep);
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }
            .prose a {
                color: var(--color-terminal-text-deep);
            }
            .prose a:hover {
                color: var(--color-terminal-text);
            }
            .prose strong {
                color: var(--color-terminal-text-deep);
            }
            .prose code {
                color: var(--color-terminal-text);
                background: rgb(255 176 0 / 0.1);
                padding: 0.1em 0.3em;
            }
            .prose pre {
                background: rgb(255 176 0 / 0.05);
                border: 1px solid var(--color-terminal-muted);
                padding: 0.75rem;
            }
            .prose pre code {
                background: transparent;
                padding: 0;
            }
            .prose blockquote {
                border-left: 3px solid var(--color-terminal-muted);
                color: var(--color-terminal-dim);
            }
            .prose ul, .prose ol {
                color: var(--color-terminal-text);
            }
            .prose hr {
                border-color: var(--color-terminal-muted);
            }
        }

        .key-indicator {
            display: none;
        }
        .key-indicator.visible {
            display: inline-flex;
        }
        .model-options {
            display: none;
        }
        .model-options.active {
            display: block;
        }
        .clear-key-button {
            display: none;
        }
        .clear-key-button.visible {
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="min-h-screen p-5">
    <div class="max-w-6xl mx-auto crt-screen scanlines p-8">
        <h1 class="text-[18px] uppercase tracking-[2px] text-glow mb-8 text-center">LLM API COMPARATOR<span class="cursor-blink">_</span></h1>

        <div class="terminal-box mb-6">
            <div class="terminal-box-title">┤ API PROVIDERS ├</div>
            <div class="space-y-4">
                <div class="p-3 border-l-highlight">
                    <div class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="openai-provider" class="provider-checkbox terminal-checkbox" data-provider="openai">
                        <label for="openai-provider" class="cursor-pointer text-terminal-text">OpenAI</label>
                        <span class="key-indicator items-center gap-1.5 ml-auto text-[10px] text-terminal-green" data-provider="openai" title="API key saved">
                            <span>●</span>
                            KEY SAVED
                        </span>
                        <button class="clear-key-button terminal-btn-danger text-[10px] px-2 py-1" data-provider="openai">CLEAR KEY</button>
                    </div>
                    <div class="model-options ml-6 mt-3 pt-3 border-t border-terminal-muted" id="openai-models">
                        <div class="text-[11px] text-terminal-dim uppercase tracking-wide mb-2">Saved models</div>
                        <div class="saved-models flex flex-col gap-1.5" id="openai-saved-models"></div>
                        <div class="flex items-center gap-2 py-1.5">
                            <input type="checkbox" id="openai-gpt5nano" class="terminal-checkbox" data-provider="openai" data-model="gpt-5-nano">
                            <label for="openai-gpt5nano" class="cursor-pointer text-terminal-dim text-[12px]">gpt-5-nano</label>
                        </div>
                        <div class="mt-2 flex items-center gap-2">
                            <input type="text" id="openai-custom" placeholder="> Custom model name..." data-provider="openai" class="terminal-input flex-1">
                            <button id="openai-save-model" class="terminal-btn-success">SAVE</button>
                        </div>
                    </div>
                </div>

                <div class="p-3 border-l-highlight">
                    <div class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="anthropic-provider" class="provider-checkbox terminal-checkbox" data-provider="anthropic">
                        <label for="anthropic-provider" class="cursor-pointer text-terminal-text">Anthropic</label>
                        <span class="key-indicator items-center gap-1.5 ml-auto text-[10px] text-terminal-green" data-provider="anthropic" title="API key saved">
                            <span>●</span>
                            KEY SAVED
                        </span>
                        <button class="clear-key-button terminal-btn-danger text-[10px] px-2 py-1" data-provider="anthropic">CLEAR KEY</button>
                    </div>
                    <div class="model-options ml-6 mt-3 pt-3 border-t border-terminal-muted" id="anthropic-models">
                        <div class="text-[11px] text-terminal-dim uppercase tracking-wide mb-2">Saved models</div>
                        <div class="saved-models flex flex-col gap-1.5" id="anthropic-saved-models"></div>
                        <div class="flex items-center gap-2 py-1.5">
                            <input type="checkbox" id="anthropic-haiku3" class="terminal-checkbox" data-provider="anthropic" data-model="claude-3-haiku-20240307">
                            <label for="anthropic-haiku3" class="cursor-pointer text-terminal-dim text-[12px]">claude-3-haiku</label>
                        </div>
                        <div class="flex items-center gap-2 py-1.5">
                            <input type="checkbox" id="anthropic-haiku35" class="terminal-checkbox" data-provider="anthropic" data-model="claude-3-5-haiku-20241022">
                            <label for="anthropic-haiku35" class="cursor-pointer text-terminal-dim text-[12px]">claude-3.5-haiku</label>
                        </div>
                        <div class="flex items-center gap-2 py-1.5">
                            <input type="checkbox" id="anthropic-haiku45" class="terminal-checkbox" data-provider="anthropic" data-model="claude-haiku-4-5-20251001">
                            <label for="anthropic-haiku45" class="cursor-pointer text-terminal-dim text-[12px]">claude-4.5-haiku</label>
                        </div>
                        <div class="mt-2 flex items-center gap-2">
                            <input type="text" id="anthropic-custom" placeholder="> Custom model name..." data-provider="anthropic" class="terminal-input flex-1">
                            <button id="anthropic-save-model" class="terminal-btn-success">SAVE</button>
                        </div>
                    </div>
                </div>

                <div class="p-3 border-l-highlight">
                    <div class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="gemini-provider" class="provider-checkbox terminal-checkbox" data-provider="gemini">
                        <label for="gemini-provider" class="cursor-pointer text-terminal-text">Google Gemini</label>
                        <span class="key-indicator items-center gap-1.5 ml-auto text-[10px] text-terminal-green" data-provider="gemini" title="API key saved">
                            <span>●</span>
                            KEY SAVED
                        </span>
                        <button class="clear-key-button terminal-btn-danger text-[10px] px-2 py-1" data-provider="gemini">CLEAR KEY</button>
                    </div>
                    <div class="model-options ml-6 mt-3 pt-3 border-t border-terminal-muted" id="gemini-models">
                        <div class="text-[11px] text-terminal-dim uppercase tracking-wide mb-2">Saved models</div>
                        <div class="saved-models flex flex-col gap-1.5" id="gemini-saved-models"></div>
                        <div class="flex items-center gap-2 py-1.5">
                            <input type="checkbox" id="gemini-flash" class="terminal-checkbox" data-provider="gemini" data-model="gemini-2.5-flash-lite">
                            <label for="gemini-flash" class="cursor-pointer text-terminal-dim text-[12px]">gemini-2.5-flash-lite</label>
                        </div>
                        <div class="flex items-center gap-2 py-1.5">
                            <input type="checkbox" id="gemini-flash3" class="terminal-checkbox" data-provider="gemini" data-model="gemini-3-flash-preview">
                            <label for="gemini-flash3" class="cursor-pointer text-terminal-dim text-[12px]">gemini-3-flash-preview</label>
                        </div>
                        <div class="mt-2 flex items-center gap-2">
                            <input type="text" id="gemini-custom" placeholder="> Custom model name..." data-provider="gemini" class="terminal-input flex-1">
                            <button id="gemini-save-model" class="terminal-btn-success">SAVE</button>
                        </div>
                    </div>
                </div>

                <div class="p-3 border-l-highlight">
                    <div class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="openrouter-provider" class="provider-checkbox terminal-checkbox" data-provider="openrouter">
                        <label for="openrouter-provider" class="cursor-pointer text-terminal-text">OpenRouter</label>
                        <span class="key-indicator items-center gap-1.5 ml-auto text-[10px] text-terminal-green" data-provider="openrouter" title="API key saved">
                            <span>●</span>
                            KEY SAVED
                        </span>
                        <button class="clear-key-button terminal-btn-danger text-[10px] px-2 py-1" data-provider="openrouter">CLEAR KEY</button>
                    </div>
                    <div class="model-options ml-6 mt-3 pt-3 border-t border-terminal-muted" id="openrouter-models">
                        <div class="text-[11px] text-terminal-dim uppercase tracking-wide mb-2">Saved models</div>
                        <div class="saved-models flex flex-col gap-1.5" id="openrouter-saved-models"></div>
                        <div class="mt-2 flex items-center gap-2">
                            <input type="text" id="openrouter-custom" placeholder="> Model name (e.g., openai/gpt-3.5-turbo)..." data-provider="openrouter" class="terminal-input flex-1">
                            <button id="openrouter-save-model" class="terminal-btn-success">SAVE</button>
                        </div>
                    </div>
                </div>

                <div id="customProvidersContainer" class="space-y-4"></div>
                <button id="addCustomProviderButton" class="w-full border border-dashed border-terminal-muted p-4 text-center text-terminal-dim cursor-pointer transition-all duration-100 hover:border-terminal-text hover:text-terminal-text hover:bg-[rgb(255_176_0_/_0.05)]">+ ADD CUSTOM OR LOCAL PROVIDER</button>
            </div>
        </div>

        <div class="terminal-box mb-6">
            <div class="terminal-box-title">┤ IMPORT/EXPORT ├</div>
            <div class="flex flex-wrap gap-2">
                <button id="downloadPrompts" class="terminal-btn">DOWNLOAD JSON</button>
                <button id="uploadPrompts" class="terminal-btn">UPLOAD JSON</button>
                <button id="loadFromGist" class="terminal-btn">LOAD FROM GIST</button>
            </div>
            <input type="file" id="uploadPromptsFile" accept="application/json" class="hidden">
            <div id="gistLoader" class="hidden mt-4 pt-4 border-t border-terminal-muted flex flex-col gap-2">
                <label for="gistInput" class="text-[11px] text-terminal-dim uppercase tracking-wide">Gist URL or ID</label>
                <div class="flex flex-col sm:flex-row gap-2">
                    <input id="gistInput" type="text" placeholder="> https://gist.github.com/username/abcdef... or gist id" class="terminal-input flex-1">
                    <button id="fetchGistButton" class="terminal-btn-primary">FETCH</button>
                </div>
                <div id="gistStatus" class="text-[11px] text-terminal-dim"></div>
            </div>
        </div>

        <div class="terminal-box mb-6">
            <div class="terminal-box-title">┤ SYSTEM PROMPT ├</div>
            <textarea id="systemPrompt" placeholder="> Enter your system prompt here..." class="terminal-input resize-y min-h-[100px]">You are a helpful assistant.</textarea>
        </div>

        <!-- Conversation Rounds Section -->
        <div class="terminal-box mb-6">
            <div class="terminal-box-title">┤ CONVERSATION ROUNDS ├</div>
            <div class="flex justify-end mb-4">
                <button id="addConversationRound" class="terminal-btn">+ ADD ROUND</button>
            </div>
            <div id="conversationRoundsContainer" class="space-y-3"></div>
        </div>

        <div class="flex gap-4 mb-8">
            <button id="sendButton" class="terminal-btn-primary flex-1 py-3 text-[13px] disabled:opacity-40 disabled:cursor-not-allowed">SEND TO APIS</button>
        </div>

        <div class="terminal-box">
            <div class="terminal-box-title">┤ RESULTS ├</div>
            <div class="grid grid-cols-1 md:grid-cols-[repeat(auto-fit,minmax(300px,1fr))] gap-5" id="resultsGrid"></div>
        </div>
    </div>

    <script>
        const BUILTIN_PROVIDERS = ['openai', 'anthropic', 'gemini', 'openrouter'];
        const API_CONFIGS = {
            openai: {
                name: 'OpenAI',
                storageKey: 'openai_api_key',
                endpoint: 'https://api.openai.com/v1/chat/completions',
                type: 'openai',
                requiresApiKey: true,
                promptForKey: true
            },
            anthropic: {
                name: 'Anthropic',
                storageKey: 'anthropic_api_key',
                endpoint: 'https://api.anthropic.com/v1/messages',
                type: 'anthropic',
                requiresApiKey: true,
                promptForKey: true
            },
            gemini: {
                name: 'Gemini',
                storageKey: 'gemini_api_key',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/models',
                type: 'gemini',
                requiresApiKey: true,
                promptForKey: true
            },
            openrouter: {
                name: 'OpenRouter',
                storageKey: 'openrouter_api_key',
                endpoint: 'https://openrouter.ai/api/v1/chat/completions',
                type: 'openrouter',
                requiresApiKey: true,
                promptForKey: true
            }
        };
        const SAVED_MODELS_KEYS = {
            openai: 'openai_saved_models',
            anthropic: 'anthropic_saved_models',
            gemini: 'gemini_saved_models',
            openrouter: 'openrouter_saved_models'
        };
        const CUSTOM_PROVIDERS_STORAGE_KEY = 'custom_providers';
        let customProviders = [];
        const SELECTED_MODELS_STORAGE_KEY = 'selected_models_by_provider';
        let selectedModelsState = {};

        function loadSelectedModelsState() {
            selectedModelsState = {};
            const raw = localStorage.getItem(SELECTED_MODELS_STORAGE_KEY);
            if (!raw) return;

            try {
                const parsed = JSON.parse(raw);
                if (parsed && typeof parsed === 'object') {
                    Object.entries(parsed).forEach(([provider, models]) => {
                        if (Array.isArray(models)) {
                            const cleaned = models
                                .filter(m => typeof m === 'string' && m.trim())
                                .map(m => m.trim());
                            if (cleaned.length) {
                                selectedModelsState[provider] = cleaned;
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to parse selected models state:', error);
            }
        }

        function persistSelectedModelsState() {
            localStorage.setItem(SELECTED_MODELS_STORAGE_KEY, JSON.stringify(selectedModelsState));
        }

        function loadCustomProvidersFromStorage() {
            customProviders = [];
            const raw = localStorage.getItem(CUSTOM_PROVIDERS_STORAGE_KEY);
            if (!raw) return;

            try {
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed)) {
                    customProviders = parsed
                        .map(item => ({
                            id: typeof item.id === 'string' ? item.id : generateCustomProviderId(),
                            name: typeof item.name === 'string' ? item.name : '',
                            endpoint: typeof item.endpoint === 'string' ? item.endpoint : '',
                            apiKey: typeof item.apiKey === 'string' ? item.apiKey : '',
                            models: Array.isArray(item.models) ? item.models.filter(m => typeof m === 'string' && m.trim()).map(m => m.trim()) : []
                        }));
                }
            } catch (error) {
                console.error('Failed to parse custom providers:', error);
            }
        }

        function persistCustomProviders() {
            localStorage.setItem(CUSTOM_PROVIDERS_STORAGE_KEY, JSON.stringify(customProviders));
        }

        function syncCustomProvidersToConfigs() {
            // remove stale custom configs
            Object.keys(API_CONFIGS)
                .filter(key => API_CONFIGS[key].custom)
                .forEach(key => delete API_CONFIGS[key]);

            customProviders.forEach(provider => {
                API_CONFIGS[provider.id] = {
                    name: provider.name?.trim() || 'Custom Provider',
                    endpoint: provider.endpoint || '',
                    type: 'openai-compatible',
                    requiresApiKey: false,
                    promptForKey: false,
                    custom: true
                };
            });
        }

        function getAllProviderIds() {
            return [...BUILTIN_PROVIDERS, ...customProviders.map(p => p.id)];
        }

        function getCustomProvider(providerId) {
            return customProviders.find(p => p.id === providerId);
        }

        function generateCustomProviderId() {
            const randomId = (window.crypto && typeof window.crypto.randomUUID === 'function')
                ? window.crypto.randomUUID()
                : `${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            return `custom-${randomId}`;
        }

        function updateCustomProvider(providerId, changes = {}) {
            const provider = getCustomProvider(providerId);
            if (!provider) return;
            Object.assign(provider, changes);
            persistCustomProviders();
            syncCustomProvidersToConfigs();
        }

        function getProviderDisplayName(providerId) {
            const config = API_CONFIGS[providerId];
            if (config && config.name) return config.name;
            const custom = getCustomProvider(providerId);
            return custom?.name?.trim() || 'Custom Provider';
        }

        function renderCustomProviders() {
            const container = document.getElementById('customProvidersContainer');
            if (!container) return;

            syncCustomProvidersToConfigs();

            container.innerHTML = '';

            if (!customProviders.length) {
                const empty = document.createElement('div');
                empty.className = 'p-3 border border-terminal-muted text-[11px] text-terminal-dim';
                empty.textContent = 'No custom providers yet. Add one to point at a local or self-hosted OpenAI-compatible API.';
                container.appendChild(empty);
            }

            customProviders.forEach(provider => {
                const card = document.createElement('div');
                card.className = 'p-3 border-l-highlight';
                card.dataset.providerId = provider.id;

                const checkboxId = `${provider.id}-provider`;
                const nameValue = provider.name || '';
                const endpointValue = provider.endpoint || '';
                const apiKeyValue = provider.apiKey || '';
                const labelText = nameValue.trim() || 'Custom Provider';

                card.innerHTML = `
                    <div class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="${checkboxId}" class="provider-checkbox terminal-checkbox" data-provider="${provider.id}">
                        <label for="${checkboxId}" class="cursor-pointer text-terminal-text" data-provider-label="${provider.id}">Custom Provider</label>
                        <span class="key-indicator items-center gap-1.5 ml-auto text-[10px] text-terminal-green" data-provider="${provider.id}" title="API key saved">
                            <span>●</span>
                            KEY SAVED
                        </span>
                        <button class="clear-key-button terminal-btn-danger text-[10px] px-2 py-1" data-provider="${provider.id}">CLEAR KEY</button>
                    </div>
                    <div class="grid sm:grid-cols-2 gap-3 mt-3">
                        <div class="space-y-1.5">
                            <label class="text-[11px] text-terminal-dim uppercase tracking-wide">Name (optional)</label>
                            <input type="text" data-provider-id="${provider.id}" data-field="name" class="terminal-input" placeholder="> Custom Provider">
                        </div>
                        <div class="space-y-1.5">
                            <label class="text-[11px] text-terminal-dim uppercase tracking-wide">API Endpoint</label>
                            <input type="text" data-provider-id="${provider.id}" data-field="endpoint" class="terminal-input" placeholder="> http://localhost:11434/v1">
                        </div>
                        <div class="sm:col-span-2 space-y-1.5">
                            <label class="text-[11px] text-terminal-dim uppercase tracking-wide">API Key (optional)</label>
                            <input type="password" data-provider-id="${provider.id}" data-field="apiKey" class="terminal-input" placeholder="> Bearer token for this endpoint">
                            <p class="text-[10px] text-terminal-muted mt-1">Stored locally and sent as a Bearer token only if provided.</p>
                        </div>
                    </div>
                    <div class="model-options ml-0 sm:ml-6 mt-3 pt-3 border-t border-terminal-muted" id="${provider.id}-models">
                        <div class="text-[11px] text-terminal-dim uppercase tracking-wide mb-2">Saved models</div>
                        <div class="saved-models flex flex-col gap-1.5" id="${provider.id}-saved-models"></div>
                        <div class="mt-2 flex items-center gap-2">
                            <input type="text" id="${provider.id}-custom" placeholder="> Model name (e.g., llama3.1:latest)..." data-provider="${provider.id}" class="terminal-input flex-1">
                            <button id="${provider.id}-save-model" class="terminal-btn-success">SAVE</button>
                        </div>
                    </div>
                `;

                container.appendChild(card);

                const nameInput = card.querySelector('input[data-field="name"]');
                const endpointInput = card.querySelector('input[data-field="endpoint"]');
                const apiKeyInput = card.querySelector('input[data-field="apiKey"]');
                const nameLabel = card.querySelector(`[data-provider-label="${provider.id}"]`);

                if (nameLabel) {
                    nameLabel.textContent = labelText;
                }

                if (nameInput) {
                    nameInput.value = nameValue;
                }

                if (endpointInput) {
                    endpointInput.value = endpointValue;
                }

                if (apiKeyInput) {
                    apiKeyInput.value = apiKeyValue;
                }

                if (nameInput) {
                    nameInput.addEventListener('input', (event) => {
                        const value = event.target.value || '';
                        updateCustomProvider(provider.id, { name: value });
                        if (nameLabel) {
                            nameLabel.textContent = value.trim() || 'Custom Provider';
                        }
                    });
                }

                if (endpointInput) {
                    endpointInput.addEventListener('input', (event) => {
                        updateCustomProvider(provider.id, { endpoint: event.target.value || '' });
                    });
                }

                if (apiKeyInput) {
                    apiKeyInput.addEventListener('input', (event) => {
                        updateCustomProvider(provider.id, { apiKey: event.target.value || '' });
                        updateKeyIndicator(provider.id);
                    });
                }

                attachSaveButtonHandler(provider.id);
            });

            setupProviderCheckboxes();
            renderAllSavedModels();
            applySelectedModelsToCheckboxes();
            updateAllKeyIndicators();
        }

        function addCustomProvider() {
            const id = generateCustomProviderId();
            customProviders.push({
                id,
                name: '',
                endpoint: '',
                apiKey: '',
                models: []
            });
            persistCustomProviders();
            syncCustomProvidersToConfigs();
            renderCustomProviders();
            const nameInput = document.querySelector(`input[data-provider-id="${id}"][data-field="name"]`);
            if (nameInput) {
                nameInput.focus();
            }
        }

        function isModelSelected(provider, model) {
            const trimmed = (model || '').trim();
            if (!provider || !trimmed) return false;
            const list = selectedModelsState[provider] || [];
            return list.some(item => item.toLowerCase() === trimmed.toLowerCase());
        }

        function setModelSelected(provider, model, isSelected) {
            const trimmed = (model || '').trim();
            if (!provider || !trimmed) return;

            if (!selectedModelsState[provider]) {
                selectedModelsState[provider] = [];
            }

            const list = selectedModelsState[provider];
            const existingIndex = list.findIndex(item => item.toLowerCase() === trimmed.toLowerCase());

            if (isSelected) {
                if (existingIndex === -1) {
                    list.push(trimmed);
                }
            } else if (existingIndex !== -1) {
                list.splice(existingIndex, 1);
            }

            if (selectedModelsState[provider] && selectedModelsState[provider].length === 0) {
                delete selectedModelsState[provider];
            }

            persistSelectedModelsState();
        }

        function applySelectedModelsToCheckboxes() {
            document.querySelectorAll('input[type="checkbox"][data-provider][data-model]').forEach(cb => {
                const provider = cb.dataset.provider;
                const model = cb.dataset.model;
                cb.checked = isModelSelected(provider, model);
            });
        }

        loadSelectedModelsState();
        loadCustomProvidersFromStorage();
        syncCustomProvidersToConfigs();

        // Pricing data cache
        let pricingData = [];

        // Fetch pricing data
        async function fetchPricingData() {
            try {
                const response = await fetch('https://www.llm-prices.com/current-v1.json');
                const data = await response.json();
                pricingData = data.prices || [];
                console.log('Pricing data loaded:', pricingData.length, 'models');
            } catch (error) {
                console.error('Failed to load pricing data:', error);
                pricingData = [];
            }
        }

        function getSavedModels(provider) {
            const custom = getCustomProvider(provider);
            if (custom) {
                return (Array.isArray(custom.models) ? custom.models : [])
                    .filter(item => typeof item === 'string' && item.trim())
                    .map(item => item.trim());
            }

            const key = SAVED_MODELS_KEYS[provider];
            if (!key) return [];
            const saved = localStorage.getItem(key);
            if (!saved) return [];

            try {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed)) {
                    return parsed
                        .filter(item => typeof item === 'string' && item.trim())
                        .map(item => item.trim());
                }
            } catch (error) {
                console.error(`Failed to parse saved ${provider} models:`, error);
            }

            return [];
        }

        function persistSavedModels(provider, models) {
            const custom = getCustomProvider(provider);
            if (custom) {
                custom.models = models;
                persistCustomProviders();
                return;
            }

            const key = SAVED_MODELS_KEYS[provider];
            if (!key) return;
            localStorage.setItem(key, JSON.stringify(models));
        }

        function renderSavedModels(provider) {
            const container = document.getElementById(`${provider}-saved-models`);
            if (!container) return;

            const previouslyChecked = new Set(
                Array.from(container.querySelectorAll('input[type=\"checkbox\"][data-model]'))
                    .filter(cb => cb.checked)
                    .map(cb => cb.dataset.model)
            );

            container.innerHTML = '';
            const models = getSavedModels(provider);

            if (models.length === 0) {
                container.innerHTML = '<div class="text-terminal-muted text-[11px]">No saved models yet</div>';
                return;
            }

            models.forEach((model, index) => {
                const checkboxId = `${provider}-saved-${index}-${model.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`;
                const wrapper = document.createElement('div');
                wrapper.className = 'flex items-center gap-2 py-1.5';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = checkboxId;
                checkbox.className = 'terminal-checkbox';
                checkbox.dataset.provider = provider;
                checkbox.dataset.model = model;
                checkbox.checked = previouslyChecked.has(model) || isModelSelected(provider, model);

                const label = document.createElement('label');
                label.setAttribute('for', checkboxId);
                label.className = 'cursor-pointer text-terminal-dim text-[12px]';
                label.textContent = model;

                const deleteButton = document.createElement('button');
                deleteButton.className = 'terminal-btn-danger text-[10px] px-2 py-1';
                deleteButton.textContent = '✕';
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    removeSavedModel(provider, model);
                });

                wrapper.appendChild(checkbox);
                wrapper.appendChild(label);
                wrapper.appendChild(deleteButton);
                container.appendChild(wrapper);
            });
        }

        function renderAllSavedModels() {
            getAllProviderIds().forEach(renderSavedModels);
        }

        function addSavedModel(provider, model) {
            const trimmed = (model || '').trim();
            const isCustom = Boolean(getCustomProvider(provider));
            if (!trimmed || (!isCustom && !SAVED_MODELS_KEYS[provider])) return false;

            const savedModels = getSavedModels(provider);
            const exists = savedModels.some(m => m.toLowerCase() === trimmed.toLowerCase());
            if (exists) return false;

            savedModels.push(trimmed);
            persistSavedModels(provider, savedModels);
            renderSavedModels(provider);
            return true;
        }

        function removeSavedModel(provider, model) {
            const savedModels = getSavedModels(provider);
            const filtered = savedModels.filter(m => m.toLowerCase() !== (model || '').toLowerCase());
            persistSavedModels(provider, filtered);
            setModelSelected(provider, model, false);
            renderSavedModels(provider);
        }

        // Count tokens using gpt-tokenizer
        function countTokens(text) {
            try {
                const encoded = GPTTokenizer_o200k_base.encode(text);
                return encoded.length;
            } catch (error) {
                console.error('Token counting error:', error);
                return 0;
            }
        }

        // Get pricing for a model
        function getModelPricing(provider, modelName) {
            if (!pricingData || !Array.isArray(pricingData) || pricingData.length === 0) return null;

            // Normalize model name for matching
            const normalizedModel = modelName.toLowerCase();
            
            // Search through pricing data
            for (const item of pricingData) {
                const itemModel = (item.id || '').toLowerCase();
                const itemVendor = (item.vendor || '').toLowerCase();
                
                // Check if model matches
                if (itemModel.includes(normalizedModel) || normalizedModel.includes(itemModel)) {
                    // For some providers, also check vendor name
                    if (provider === 'anthropic' && itemVendor === 'anthropic') {
                        return item;
                    } else if (provider === 'openai' && itemVendor === 'openai') {
                        return item;
                    } else if (provider === 'gemini' && itemVendor === 'google') {
                        return item;
                    } else if (provider === 'openrouter') {
                        // OpenRouter can use any model, so just match on model name
                        return item;
                    }
                }
            }
            
            return null;
        }

        // Calculate and format pricing
        function calculatePricing(provider, model, inputTokens, outputTokens) {
            const pricing = getModelPricing(provider, model);
            
            if (!pricing) {
                return {
                    inputPrice: 'Unknown',
                    outputPrice: 'Unknown',
                    totalPrice: 'Unknown',
                    isUnknown: true
                };
            }

            // Pricing is typically per million tokens
            const inputPrice = (inputTokens / 1000000) * (pricing.input || 0);
            const outputPrice = (outputTokens / 1000000) * (pricing.output || 0);
            const totalPrice = inputPrice + outputPrice;

            return {
                inputPrice: `$${inputPrice.toFixed(6)}`,
                outputPrice: `$${outputPrice.toFixed(6)}`,
                totalPrice: `$${totalPrice.toFixed(6)}`,
                isUnknown: false
            };
        }

        // Load pricing data on page load
        fetchPricingData();

        // Load saved prompts and conversation rounds on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedSystemPrompt = localStorage.getItem('saved_system_prompt');
            const savedConversationRounds = localStorage.getItem('saved_conversation_rounds');
            
            if (savedSystemPrompt) {
                document.getElementById('systemPrompt').value = savedSystemPrompt;
            }
            
            // Load saved conversation rounds
            if (savedConversationRounds) {
                try {
                    const rounds = JSON.parse(savedConversationRounds);
                    if (Array.isArray(rounds)) {
                        rounds.forEach(round => {
                            addConversationRound(round.role, round.message, false);
                        });
                    }
                } catch (error) {
                    console.error('Failed to parse conversation rounds:', error);
                }
            }

            renderCustomProviders();
            getAllProviderIds().forEach(attachSaveButtonHandler);

            const params = new URLSearchParams(window.location.search);
            const gistParam = extractGistId(params.get('gist') || '');
            if (gistParam) {
                if (gistLoader) {
                    gistLoader.classList.remove('hidden');
                }
                if (gistInput) {
                    gistInput.value = gistParam;
                }
                setGistStatus('Loading gist...', 'text-terminal-dim');
                fetchGistAndImport(gistParam, setGistStatus).then(success => {
                    if (success) {
                        updateUrlWithGistId(gistParam);
                    } else {
                        updateUrlWithGistId('');
                    }
                });
            }
        });

        // Function to create a conversation round element
        function createConversationRoundElement(roundId, role, message) {
            const roundElement = document.createElement('div');
            roundElement.className = 'border-l-[3px] border-terminal-text p-3';
            roundElement.dataset.roundId = roundId;

            roundElement.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center gap-2">
                        <span class="text-terminal-text-deep text-[11px]">${role === 'user' ? '>>>' : '<<<'}</span>
                        <select class="bg-terminal-bg border border-terminal-muted text-terminal-text px-2 py-1 text-[11px] uppercase tracking-wide cursor-pointer outline-none focus:border-terminal-text" data-round-id="${roundId}">
                            <option value="user" ${role === 'user' ? 'selected' : ''}>USER</option>
                            <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>ASSISTANT</option>
                        </select>
                    </div>
                    <button class="terminal-btn-danger text-[10px] px-2 py-1" data-round-id="${roundId}">DELETE</button>
                </div>
                <textarea class="terminal-input resize-y min-h-[80px]" placeholder="> Enter message content..." data-round-id="${roundId}">${message || ''}</textarea>
            `;

            return roundElement;
        }

        // Function to add a conversation round
        function addConversationRound(role = 'user', message = '', saveToStorage = true) {
            const container = document.getElementById('conversationRoundsContainer');
            const roundId = 'round-' + Date.now();
            
            const roundElement = createConversationRoundElement(roundId, role, message);
            container.appendChild(roundElement);
            
            // Add event listeners for the new elements
            const selectElement = roundElement.querySelector('select');
            const deleteButton = roundElement.querySelector('button');
            const textareaElement = roundElement.querySelector('textarea');

            const handleRoundChange = () => {
                markPromptsModified();
                saveConversationRounds();
            };
            
            selectElement.addEventListener('change', handleRoundChange);
            textareaElement.addEventListener('input', handleRoundChange);
            deleteButton.addEventListener('click', () => {
                roundElement.remove();
                handleRoundChange();
            });
            
            if (saveToStorage) {
                handleRoundChange();
            }
        }

        function getConversationRoundsFromDOM() {
            const roundElements = document.getElementById('conversationRoundsContainer').children;

            return Array.from(roundElements).map(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                return {
                    role: select ? select.value : 'user',
                    message: textarea ? textarea.value : ''
                };
            });
        }

        // Function to save conversation rounds to local storage
        function saveConversationRounds() {
            const rounds = getConversationRoundsFromDOM();
            localStorage.setItem('saved_conversation_rounds', JSON.stringify(rounds));
        }

        // Save prompts as user types
        document.getElementById('systemPrompt').addEventListener('input', (e) => {
            localStorage.setItem('saved_system_prompt', e.target.value);
            markPromptsModified();
        });

        function getStoredApiKey(provider) {
            const config = API_CONFIGS[provider];
            if (!config) return '';

            if (config.storageKey) {
                return localStorage.getItem(config.storageKey) || '';
            }

            const custom = getCustomProvider(provider);
            return custom?.apiKey || '';
        }

        function setStoredApiKey(provider, value) {
            const config = API_CONFIGS[provider];
            if (!config) return;

            if (config.storageKey) {
                if (value) {
                    localStorage.setItem(config.storageKey, value);
                } else {
                    localStorage.removeItem(config.storageKey);
                }
                return;
            }

            const custom = getCustomProvider(provider);
            if (custom) {
                custom.apiKey = value || '';
                persistCustomProviders();
            }
        }

        function updateKeyIndicator(provider) {
            const indicator = document.querySelector(`.key-indicator[data-provider="${provider}"]`);
            const clearButton = document.querySelector(`.clear-key-button[data-provider="${provider}"]`);
            if (!indicator) return;
            
            const hasKey = Boolean(getStoredApiKey(provider));
            indicator.classList.toggle('visible', hasKey);
            if (clearButton) {
                clearButton.classList.toggle('visible', hasKey);
            }
        }

        function updateAllKeyIndicators() {
            getAllProviderIds().forEach(updateKeyIndicator);
        }

        function getApiKey(provider) {
            const config = API_CONFIGS[provider];
            if (!config) return '';

            let apiKey = getStoredApiKey(provider);
            
            if (!apiKey && config.promptForKey !== false) {
                apiKey = window.prompt(`Enter your ${config.name} API key:`);
                if (apiKey) {
                    setStoredApiKey(provider, apiKey);
                    updateKeyIndicator(provider);
                }
            }
            
            return apiKey || '';
        }

        function clearApiKey(provider) {
            setStoredApiKey(provider, '');
            updateKeyIndicator(provider);
        }

        function createResultCard(provider, model) {
            const cardId = `result-${provider}-${model.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const card = document.createElement('div');
            card.className = 'border border-terminal-muted p-4';
            card.id = cardId;
            card.innerHTML = `
                <div class="flex items-center justify-between mb-4 pb-2.5 border-b border-terminal-muted">
                    <div>
                        <div class="text-terminal-text text-[13px] uppercase tracking-wide">${getProviderDisplayName(provider)}</div>
                        <div class="text-[10px] text-terminal-dim mt-0.5">${model}</div>
                    </div>
                    <div class="result-status text-[10px] text-terminal-success">LOADING...</div>
                </div>
                <div class="result-content text-terminal-dim leading-relaxed">
                    <div class="flex gap-2 mb-3">
                        <button class="result-tab-btn terminal-btn-primary text-[10px]" data-tab="text">TEXT</button>
                        <button class="result-tab-btn terminal-btn text-[10px]" data-tab="markdown">MARKDOWN</button>
                        <button class="result-tab-btn terminal-btn text-[10px]" data-tab="cost">COST</button>
                    </div>
                    <div class="border border-terminal-muted p-3 min-h-[120px] bg-[rgb(255_176_0_/_0.02)]">
                        <div class="tab-panel whitespace-pre-wrap break-words text-[12px]" data-tab="text">
                            <div class="loading inline-block w-4 h-4 border-2 border-terminal-muted border-t-terminal-text rounded-full"></div>
                        </div>
                        <div class="tab-panel hidden prose prose-sm max-w-none text-terminal-text text-[12px]" data-tab="markdown"></div>
                        <div class="tab-panel hidden text-[11px]" data-tab="cost">
                            <p class="text-terminal-dim">Cost details will appear after a successful response.</p>
                        </div>
                    </div>
                </div>
            `;

            const tabButtons = card.querySelectorAll('.result-tab-btn');
            const tabPanels = card.querySelectorAll('.tab-panel');

            const setActiveTab = (tab) => {
                tabButtons.forEach(btn => {
                    const isActive = btn.dataset.tab === tab;
                    if (isActive) {
                        btn.className = 'result-tab-btn terminal-btn-primary text-[10px]';
                    } else {
                        btn.className = 'result-tab-btn terminal-btn text-[10px]';
                    }
                });

                tabPanels.forEach(panel => {
                    panel.classList.toggle('hidden', panel.dataset.tab !== tab);
                });
            };

            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => setActiveTab(btn.dataset.tab));
            });
            setActiveTab('text');
            return card;
        }

        function updateResultCard(provider, model, status, content, inputText = '', outputText = '', durationMs = null) {
            const cardId = `result-${provider}-${model.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const card = document.getElementById(cardId);
            const statusEl = card.querySelector('.result-status');
            const textPanel = card.querySelector('.tab-panel[data-tab="text"]');
            const markdownPanel = card.querySelector('.tab-panel[data-tab="markdown"]');
            const costPanel = card.querySelector('.tab-panel[data-tab="cost"]');

            const statusClasses = status === 'success'
                ? 'text-[10px] text-terminal-green'
                : 'text-[10px] text-terminal-error';
            statusEl.className = `result-status ${statusClasses}`;
            const statusLabel = status === 'success' ? '● OK' : '● ERR';
            const durationLabel = Number.isFinite(durationMs) ? `${Math.round(durationMs)}ms` : '';
            statusEl.textContent = durationLabel ? `${statusLabel} ${durationLabel}` : statusLabel;

            if (costPanel) {
                costPanel.innerHTML = '<p class="text-terminal-dim">Cost details will appear after a successful response.</p>';
            }

            const rawText = typeof content === 'string' ? content : '';
            if (textPanel) {
                textPanel.textContent = rawText;
            }
            if (markdownPanel) {
                if (status === 'success') {
                    if (window.marked) {
                        markdownPanel.innerHTML = window.marked.parse(rawText);
                    } else {
                        markdownPanel.textContent = rawText;
                    }
                } else {
                    markdownPanel.innerHTML = `<p class="text-terminal-error">${rawText || 'No content'}</p>`;
                }
            }

            if (status === 'success' && inputText && outputText) {
                // Count tokens
                const inputTokens = countTokens(inputText);
                const outputTokens = countTokens(outputText);

                // Calculate pricing
                const pricing = calculatePricing(provider, model, inputTokens, outputTokens);

                // Build pricing display
                const priceClass = pricing.isUnknown ? 'text-terminal-error italic' : '';
                const tokenInfoHTML = `
                    <div class="p-2.5 border border-terminal-muted text-[11px] leading-snug">
                        <div class="flex justify-between py-0.5">
                            <span class="text-terminal-dim uppercase">Input Tokens:</span>
                            <span class="text-terminal-text">${inputTokens.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between py-0.5">
                            <span class="text-terminal-dim uppercase">Input Price:</span>
                            <span class="text-terminal-text ${priceClass}">${pricing.inputPrice}</span>
                        </div>
                        <div class="flex justify-between py-0.5">
                            <span class="text-terminal-dim uppercase">Output Tokens:</span>
                            <span class="text-terminal-text">${outputTokens.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between py-0.5">
                            <span class="text-terminal-dim uppercase">Output Price:</span>
                            <span class="text-terminal-text ${priceClass}">${pricing.outputPrice}</span>
                        </div>
                        <div class="flex justify-between py-0.5 pt-1.5 border-t border-terminal-muted text-terminal-text-deep">
                            <span class="uppercase">Total Price:</span>
                            <span class="${priceClass}">${pricing.totalPrice}</span>
                        </div>
                    </div>
                `;

                if (costPanel) {
                    costPanel.innerHTML = tokenInfoHTML;
                }
            } else if (costPanel) {
                costPanel.innerHTML = '<p class="text-terminal-dim">Cost details unavailable.</p>';
            }
        }

        function buildOpenAIStyleMessages(systemPrompt) {
            const messages = [];

            if (systemPrompt.trim()) {
                messages.push({ role: 'system', content: systemPrompt });
            }

            const roundElements = document.getElementById('conversationRoundsContainer').children;
            Array.from(roundElements).forEach(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                if (textarea.value.trim()) {
                    messages.push({ role: select.value, content: textarea.value });
                }
            });

            return messages;
        }

        function normalizeChatCompletionEndpoint(endpoint) {
            if (!endpoint) return '';
            const trimmed = endpoint.trim().replace(/\/+$/, '');
            if (trimmed.toLowerCase().endsWith('/chat/completions')) {
                return trimmed;
            }
            return `${trimmed}/chat/completions`;
        }

        async function callOpenAICompatible(systemPrompt, apiKey, model, endpoint, extraHeaders = {}) {
            const normalizedEndpoint = normalizeChatCompletionEndpoint(endpoint);
            if (!normalizedEndpoint) {
                throw new Error('API endpoint is required for this provider.');
            }

            const messages = buildOpenAIStyleMessages(systemPrompt);
            const headers = {
                'Content-Type': 'application/json',
                ...extraHeaders
            };

            if (apiKey) {
                headers['Authorization'] = `Bearer ${apiKey}`;
            }

            const response = await fetch(normalizedEndpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    model: model,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content;
            if (!content) {
                throw new Error('No content returned from provider.');
            }
            return content;
        }

        async function callOpenAI(systemPrompt, apiKey, model) {
            return callOpenAICompatible(systemPrompt, apiKey, model, API_CONFIGS.openai.endpoint);
        }

        async function callAnthropic(systemPrompt, apiKey, model) {
            // Build messages array with conversation rounds
            const messages = [];

            // Add conversation rounds
            const roundElements = document.getElementById('conversationRoundsContainer').children;
            Array.from(roundElements).forEach(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                if (textarea.value.trim()) {
                    messages.push({ role: select.value, content: textarea.value });
                }
            });

            const response = await fetch(API_CONFIGS.anthropic.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: model,
                    max_tokens: 1000,
                    system: systemPrompt,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.content[0].text;
        }

        async function callGemini(systemPrompt, apiKey, model) {
            // Build conversation history
            let conversationText = systemPrompt;

            // Add conversation rounds
            const roundElements = document.getElementById('conversationRoundsContainer').children;
            Array.from(roundElements).forEach(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                if (textarea.value.trim()) {
                    conversationText += `\n\n${select.value.toUpperCase()}: ${textarea.value}`;
                }
            });

            const response = await fetch(`${API_CONFIGS.gemini.endpoint}/${model}:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: conversationText
                        }]
                    }]
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        async function callOpenRouter(systemPrompt, apiKey, model) {
            const headers = {
                'HTTP-Referer': window.location.href,
                'X-Title': 'LLM Comparator'
            };
            return callOpenAICompatible(systemPrompt, apiKey, model, API_CONFIGS.openrouter.endpoint, headers);
        }

        async function callAPI(provider, model, systemPrompt, apiKey) {
            const config = API_CONFIGS[provider];
            if (!config) {
                throw new Error('Unknown API');
            }

            const requiresKey = config.requiresApiKey !== false;
            if (!apiKey && requiresKey) {
                throw new Error('API key not provided');
            }

            switch (config.type) {
                case 'openai':
                    return await callOpenAI(systemPrompt, apiKey, model);
                case 'anthropic':
                    return await callAnthropic(systemPrompt, apiKey, model);
                case 'gemini':
                    return await callGemini(systemPrompt, apiKey, model);
                case 'openrouter':
                    return await callOpenRouter(systemPrompt, apiKey, model);
                case 'openai-compatible':
                    return await callOpenAICompatible(systemPrompt, apiKey, model, config.endpoint);
                default:
                    throw new Error('Unknown API');
            }
        }

        function downloadPromptsAsJSON() {
            const payload = {
                systemPrompt: document.getElementById('systemPrompt').value || '',
                conversationRounds: getConversationRoundsFromDOM()
            };

            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'prompts.json';
            link.click();
            URL.revokeObjectURL(url);
        }

        function importPromptsData(parsed) {
            if (typeof parsed !== 'object' || parsed === null) {
                throw new Error('Invalid JSON structure');
            }

            const systemPromptValue = typeof parsed.systemPrompt === 'string' ? parsed.systemPrompt : '';
            const conversationRounds = Array.isArray(parsed.conversationRounds) ? parsed.conversationRounds : [];

            const systemPromptEl = document.getElementById('systemPrompt');
            systemPromptEl.value = systemPromptValue;
            localStorage.setItem('saved_system_prompt', systemPromptValue);

            const container = document.getElementById('conversationRoundsContainer');
            container.innerHTML = '';

            conversationRounds.forEach(round => {
                const role = round && round.role === 'assistant' ? 'assistant' : 'user';
                const message = round && typeof round.message === 'string' ? round.message : '';
                addConversationRound(role, message, false);
            });

            saveConversationRounds();
        }

        function handlePromptsFileUpload(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const parsed = JSON.parse(event.target?.result || '{}');
                    importPromptsData(parsed);
                } catch (error) {
                    console.error('Failed to import prompts:', error);
                    alert('Invalid prompts file. Please upload a valid JSON export.');
                } finally {
                    const uploadInput = document.getElementById('uploadPromptsFile');
                    if (uploadInput) {
                        uploadInput.value = '';
                    }
                }
            };

            reader.readAsText(file);
        }

        document.getElementById('downloadPrompts').addEventListener('click', downloadPromptsAsJSON);

        const uploadPromptsFileInput = document.getElementById('uploadPromptsFile');
        document.getElementById('uploadPrompts').addEventListener('click', () => {
            if (uploadPromptsFileInput) {
                uploadPromptsFileInput.value = '';
                uploadPromptsFileInput.click();
            }
        });

        if (uploadPromptsFileInput) {
            uploadPromptsFileInput.addEventListener('change', (event) => {
                const file = event.target.files && event.target.files[0];
                if (file) {
                    handlePromptsFileUpload(file);
                }
            });
        }

        function extractGistId(input) {
            if (!input) return '';
            const trimmed = input.trim();
            try {
                const asUrl = new URL(trimmed);
                const parts = asUrl.pathname.split('/').filter(Boolean);
                return parts[parts.length - 1] || '';
            } catch {
                // Not a URL; assume raw id or short form
            }

            const match = trimmed.match(/[0-9a-f]{8,}/i);
            return match ? match[0] : '';
        }

        function updateUrlWithGistId(gistId) {
            const url = new URL(window.location.href);
            if (gistId) {
                url.searchParams.set('gist', gistId);
            } else {
                url.searchParams.delete('gist');
            }
            url.searchParams.delete('history');
            window.history.replaceState({}, '', url);
        }

        function clearGistAndHistoryParams() {
            const url = new URL(window.location.href);
            url.searchParams.delete('gist');
            url.searchParams.delete('history');
            window.history.replaceState({}, '', url);
            if (gistInput) {
                gistInput.value = '';
            }
            if (gistStatus) {
                gistStatus.textContent = '';
            }
        }

        function markPromptsModified() {
            clearGistAndHistoryParams();
        }

        async function fetchGistAndImport(gistId, setStatus) {
            if (!window.Octokit) {
                alert('Octokit failed to load. Please refresh and try again.');
                return false;
            }

            const octokit = new window.Octokit();
            setStatus('Loading gist...', 'text-terminal-dim');
            try {
                const response = await octokit.request('GET /gists/{gist_id}', {
                    gist_id: gistId,
                    headers: {
                        'X-GitHub-Api-Version': '2022-11-28'
                    }
                });

                const files = response.data.files || {};
                const fileList = Object.values(files);
                if (!fileList.length) throw new Error('No files found in gist.');

                const selectedFile = fileList.find(f =>
                    (f.filename || '').toLowerCase().endsWith('.json') ||
                    (f.language || '').toLowerCase() === 'json'
                ) || fileList[0];

                if (!selectedFile || !selectedFile.content) {
                    throw new Error('No readable file content found.');
                }

                const parsed = JSON.parse(selectedFile.content);
                importPromptsData(parsed);
                setStatus(`Loaded from ${selectedFile.filename || 'gist file'}`, 'text-terminal-green');
                return true;
            } catch (error) {
                console.error('Gist load failed:', error);
                alert('Failed to load gist. Please check the URL/ID and try again.');
                setStatus('Failed to load gist.', 'text-terminal-error');
                return false;
            }
        }

        function setGistStatus(message, cls = 'text-terminal-dim') {
            if (gistStatus) {
                gistStatus.className = `text-[11px] ${cls}`;
                gistStatus.textContent = message;
            }
        }

        const gistToggleButton = document.getElementById('loadFromGist');
        const gistLoader = document.getElementById('gistLoader');
        const gistInput = document.getElementById('gistInput');
        const gistStatus = document.getElementById('gistStatus');
        const fetchGistButton = document.getElementById('fetchGistButton');

        if (gistToggleButton && gistLoader) {
            gistToggleButton.addEventListener('click', () => {
                gistLoader.classList.toggle('hidden');
                gistStatus.textContent = '';
                if (!gistLoader.classList.contains('hidden')) {
                    gistInput?.focus();
                }
            });
        }

        if (fetchGistButton) {
            fetchGistButton.addEventListener('click', () => {
                const id = extractGistId(gistInput?.value || '');
                if (!id) {
                    alert('Please enter a valid Gist URL or ID.');
                    return;
                }
                fetchGistAndImport(id, setGistStatus).then(success => {
                    if (success) {
                        updateUrlWithGistId(id);
                    }
                });
            });
        }

        // Add conversation round button handler
        document.getElementById('addConversationRound').addEventListener('click', () => {
            addConversationRound();
        });

        const addCustomProviderButton = document.getElementById('addCustomProviderButton');
        if (addCustomProviderButton) {
            addCustomProviderButton.addEventListener('click', () => {
                addCustomProvider();
                getAllProviderIds().forEach(attachSaveButtonHandler);
            });
        }

        function attachSaveButtonHandler(provider) {
            const button = document.getElementById(`${provider}-save-model`);
            const input = document.getElementById(`${provider}-custom`);
            if (!button || !input) return;

            if (button.dataset.bound === 'true') return;
            button.dataset.bound = 'true';

            button.addEventListener('click', () => {
                const trimmed = input.value.trim();
                if (!trimmed) {
                    alert('Please enter a model name to save');
                    return;
                }

                const added = addSavedModel(provider, trimmed);
                if (!added) {
                    alert('Model already saved');
                    return;
                }

                input.value = '';
            });
        }

        document.addEventListener('click', (event) => {
            const button = event.target.closest('.clear-key-button');
            if (!button) return;
            const provider = button.dataset.provider;
            if (!provider) return;
            if (confirm(`Clear saved ${getProviderDisplayName(provider)} API key?`)) {
                clearApiKey(provider);
                const apiInput = document.querySelector(`input[data-provider-id="${provider}"][data-field="apiKey"]`);
                if (apiInput) {
                    apiInput.value = '';
                }
            }
        });

        function syncProviderPanel(checkbox) {
            const provider = checkbox.dataset.provider;
            const modelOptions = document.getElementById(`${provider}-models`);
            if (!modelOptions) return;
            modelOptions.classList.toggle('active', checkbox.checked);
        }

        function setupProviderCheckboxes() {
            document.querySelectorAll('.provider-checkbox').forEach(checkbox => {
                if (checkbox.dataset.bound === 'true') return;
                checkbox.dataset.bound = 'true';

                checkbox.addEventListener('change', function() {
                    syncProviderPanel(this);
                });
                syncProviderPanel(checkbox);
            });
        }

        document.addEventListener('change', (event) => {
            const target = event.target;
            if (target && target.matches('input[type="checkbox"][data-provider][data-model]')) {
                const provider = target.dataset.provider;
                const model = target.dataset.model;
                setModelSelected(provider, model, target.checked);
            }
        });

        function getSelectedModels() {
            const selections = [];
            
            document.querySelectorAll('.provider-checkbox:checked').forEach(providerCheckbox => {
                const provider = providerCheckbox.dataset.provider;
                
                // Get checked model checkboxes
                const modelCheckboxes = document.querySelectorAll(`input[type="checkbox"][data-provider="${provider}"][data-model]`);
                modelCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        selections.push({
                            provider: provider,
                            model: checkbox.dataset.model
                        });
                    }
                });
                
                // Get custom model input
                const customInput = document.getElementById(`${provider}-custom`);
                if (customInput && customInput.value.trim()) {
                    selections.push({
                        provider: provider,
                        model: customInput.value.trim()
                    });
                }
            });
            
            return selections;
        }

        function persistSelectionsToStorage(selections) {
            selections.forEach(selection => {
                setModelSelected(selection.provider, selection.model, true);
            });
            applySelectedModelsToCheckboxes();
        }

        document.getElementById('sendButton').addEventListener('click', async () => {
            const selections = getSelectedModels();

            if (selections.length === 0) {
                alert('Please select at least one provider and model');
                return;
            }

            const systemPrompt = document.getElementById('systemPrompt').value;

            // Check that conversation rounds have content
            const roundElements = document.getElementById('conversationRoundsContainer').children;
            const hasConversationContent = Array.from(roundElements).some(el =>
                el.querySelector('textarea').value.trim()
            );
            
            if (!hasConversationContent) {
                alert('Please add at least one conversation round');
                return;
            }

            getAllProviderIds().forEach(provider => {
                const customInput = document.getElementById(`${provider}-custom`);
                if (!customInput) return;
                const customValue = customInput.value.trim();
                const customUsed = selections.some(sel => sel.provider === provider && sel.model === customValue);
                if (customValue && customUsed) {
                    addSavedModel(provider, customValue);
                    setModelSelected(provider, customValue, true);
                }
            });

            persistSelectionsToStorage(selections);

            // Get unique providers that need API keys
            const uniqueProviders = [...new Set(selections.map(s => s.provider))];
            
            // Prompt for API keys upfront for all providers
            const apiKeys = {};
            for (const provider of uniqueProviders) {
                const config = API_CONFIGS[provider] || {};
                const key = getApiKey(provider);
                if (!key && config.requiresApiKey !== false) {
                    alert(`API key required for ${getProviderDisplayName(provider)}`);
                    return;
                }
                apiKeys[provider] = key || '';
            }

            const resultsGrid = document.getElementById('resultsGrid');
            resultsGrid.innerHTML = '';

            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;

            // Combined input text for token counting
            let inputText = systemPrompt;
            Array.from(roundElements).forEach(el => {
                const content = el.querySelector('textarea').value;
                if (content.trim()) {
                    inputText += '\n\n' + content;
                }
            });

            // Create result cards for all selections
            selections.forEach(selection => {
                const card = createResultCard(selection.provider, selection.model);
                resultsGrid.appendChild(card);
            });

            // Call all APIs concurrently
            const apiPromises = selections.map(selection => {
                const startTime = performance.now();
                return callAPI(selection.provider, selection.model, systemPrompt, apiKeys[selection.provider])
                    .then(result => {
                        const durationMs = performance.now() - startTime;
                        updateResultCard(selection.provider, selection.model, 'success', result, inputText, result, durationMs);
                    })
                    .catch(error => {
                        const durationMs = performance.now() - startTime;
                        updateResultCard(selection.provider, selection.model, 'error', 
                            `Error: ${error.message}`, '', '', durationMs);
                    });
            });

            await Promise.all(apiPromises);

            sendButton.disabled = false;
        });

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Comparator</title>
    <link rel="icon" href="llm_comparator.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cousine:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/gpt-tokenizer@3.4.0/dist/o200k_base.min.js"
            integrity="sha384-2mbc10In+5hSH3viAU7PCmy1WiTNtRVHTf34Xg/a3e4UWNcWFuDtNuEOvfYwReSh"
            crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4.1.18/dist/index.global.js"
            integrity="sha384-y0axVOJIfo0bJOmTOnyRyUjrqjUotl7L/k6mzSwu2SSrB3r7P+b0cSFkiod+js0X"
            crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.4/dist/purify.min.js"
            integrity="sha384-eEu5CTj3qGvu9PdJuS+YlkNi7d2XxQROAFYOr59zgObtlcux1ae1Il3u7jvdCSWu"
            crossorigin="anonymous"></script>
    <script type="module">
      import { marked } from "https://cdn.jsdelivr.net/npm/marked@17.0.1/lib/marked.esm.js";
      window.marked = marked;
    </script>
    <script type="module">
      import { Octokit } from "https://esm.sh/@octokit/core";
      window.Octokit = Octokit;
    </script>
    <style type="text/tailwindcss">
        @theme {
            /* Solarized Light Colors */
            --color-base-3: #fdf6e3;
            --color-base-2: #eee8d5;
            --color-base-1: #93a1a1;
            --color-base-00: #657b83;
            --color-base-01: #586e75;

            /* Accents */
            --color-sol-cyan: #2aa198;
            --color-sol-green: #859900;
            --color-sol-yellow: #b58900;
            --color-sol-orange: #cb4b16;
            --color-sol-red: #dc322f;
            --color-sol-magenta: #d33682;

            /* Typography */
            --font-mono: 'Cousine', 'Monaco', 'Consolas', monospace;
        }

        @layer base {
            body {
                @apply bg-base-3 text-base-00 font-mono antialiased;
                line-height: 1.6;
            }
        }

        /* Card styling */
        .card {
            background: var(--color-base-2);
            border: 1px solid rgba(147, 161, 161, 0.2);
            border-radius: 4px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(101, 123, 131, 0.08);
        }

        /* Box with title */
        .box-with-title {
            border: 1px solid rgba(147, 161, 161, 0.2);
            border-radius: 4px;
            padding: 1.5rem;
            position: relative;
            background: var(--color-base-2);
        }

        .box-title {
            position: absolute;
            top: -0.625rem;
            left: 1rem;
            background: var(--color-base-3);
            padding: 0 0.5rem;
            font-size: 0.75rem;
            color: var(--color-base-01);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Provider item highlight */
        .provider-item {
            border-left: 3px solid rgba(147, 161, 161, 0.2);
            transition: all 150ms;
            padding: 1rem;
        }

        .provider-item:hover {
            border-left-color: var(--color-sol-cyan);
            background: var(--color-base-2);
        }

        .provider-item.active {
            border-left-color: var(--color-sol-cyan);
            background: var(--color-base-2);
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-primary {
            background: var(--color-sol-cyan);
            color: var(--color-base-3);
            border: 0;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(42, 161, 152, 0.3);
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            background: transparent;
            color: var(--color-base-00);
            border: 1px solid rgba(147, 161, 161, 0.3);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-secondary:hover {
            background: var(--color-base-2);
            border-color: var(--color-sol-cyan);
        }

        .btn-danger {
            background: transparent;
            color: var(--color-sol-red);
            border: 1px solid var(--color-sol-red);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-danger:hover {
            background: rgba(220, 50, 47, 0.1);
            box-shadow: 0 4px 12px rgba(220, 50, 47, 0.2);
        }

        .btn-success {
            background: transparent;
            color: var(--color-sol-green);
            border: 1px solid var(--color-sol-green);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-success:hover {
            background: rgba(133, 153, 0, 0.1);
            box-shadow: 0 4px 12px rgba(133, 153, 0, 0.2);
        }

        .slide-panel {
            max-height: 0;
            opacity: 0;
            transform: translateY(-6px);
            overflow: hidden;
            pointer-events: none;
            margin-top: 0;
            padding-top: 0;
            border-top-width: 0;
            transition: max-height 220ms ease, opacity 200ms ease, transform 200ms ease;
        }

        .slide-panel.open {
            max-height: 600px;
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top-width: 1px;
        }

        .tab-panel {
            overflow-x: auto;
        }

        /* Form inputs */
        .form-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            background: var(--color-base-3);
            border: 1px solid rgba(147, 161, 161, 0.2);
            border-radius: 4px;
            font-size: 13px;
            color: var(--color-base-00);
            font-family: var(--font-mono);
            transition: all 200ms;
            outline: none;
        }

        .form-input:focus {
            border-color: var(--color-sol-cyan);
            box-shadow: 0 0 0 3px rgba(42, 161, 152, 0.2);
        }

        .form-input::placeholder {
            color: var(--color-base-1);
        }

        /* Checkbox */
        .checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid var(--color-base-1);
            background: var(--color-base-3);
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            border-radius: 2px;
        }

        .checkbox:checked {
            background: var(--color-sol-cyan);
            border-color: var(--color-sol-cyan);
        }

        .checkbox:checked::before {
            content: '✓';
            position: absolute;
            top: -2px;
            left: 2px;
            color: var(--color-base-3);
            font-size: 12px;
            font-weight: bold;
        }

        /* Prose styling for markdown */
        .prose {
            color: var(--color-base-00);
        }
        .prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 {
            color: var(--color-base-01);
            font-weight: 700;
        }
        .prose a {
            color: var(--color-sol-cyan);
            text-decoration: none;
        }
        .prose a:hover {
            color: var(--color-base-01);
        }
        .prose strong {
            color: var(--color-base-01);
            font-weight: 700;
        }
        .prose code {
            color: var(--color-base-00);
            background: rgba(42, 161, 152, 0.1);
            padding: 0.1em 0.3em;
            border-radius: 3px;
        }
        .prose pre {
            background: var(--color-base-2);
            border: 1px solid rgba(147, 161, 161, 0.2);
            border-left: 3px solid var(--color-sol-cyan);
            padding: 0.75rem;
            border-radius: 4px;
            overflow-x: auto;
            max-width: 100%;
            -webkit-overflow-scrolling: touch;
        }
        .prose pre code {
            background: transparent;
            padding: 0;
        }
        .prose pre {
            scrollbar-width: thin;
            scrollbar-color: rgba(147, 161, 161, 0.5) rgba(0, 0, 0, 0.08);
        }
        .prose pre::-webkit-scrollbar {
            height: 8px;
        }
        .prose pre::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.08);
            border-radius: 999px;
        }
        .prose pre::-webkit-scrollbar-thumb {
            background: rgba(147, 161, 161, 0.5);
            border-radius: 999px;
        }
        .prose pre::-webkit-scrollbar-thumb:hover {
            background: rgba(147, 161, 161, 0.75);
        }
        .prose blockquote {
            border-left: 3px solid var(--color-base-1);
            color: var(--color-base-01);
            padding-left: 1rem;
        }
        .prose ul, .prose ol {
            color: var(--color-base-00);
        }
        .prose hr {
            border-color: var(--color-base-1);
        }

        .key-indicator {
            display: none;
        }
        .key-indicator.visible {
            display: inline-flex;
        }
        .model-options {
            display: none;
        }
        .model-options.active {
            display: block;
        }
        .clear-key-button {
            display: none;
        }
        .clear-key-button.visible {
            display: inline-block;
        }

        .model-search-item {
            background: var(--color-base-3);
            border: 1px solid rgba(147, 161, 161, 0.2);
            border-radius: 4px;
            padding: 0.75rem;
            text-align: left;
            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
        }
        .model-search-item:hover {
            border-color: var(--color-sol-cyan);
            background: var(--color-base-2);
            box-shadow: 0 6px 16px rgba(101, 123, 131, 0.12);
            transform: translateY(-1px);
        }
        .model-search-meta {
            color: var(--color-base-1);
            font-size: 12px;
        }
        .model-search-description {
            color: var(--color-base-01);
            font-size: 12px;
            margin-top: 0.35rem;
            line-height: 1.4;
        }
    </style>
</head>
<body class="min-h-screen p-6">
    <!-- Fixed background gradient -->
    <div class="fixed inset-0 -z-10"
         style="background:
           linear-gradient(135deg, #fdf6e3 0%, #eee8d5 100%),
           radial-gradient(circle at 20% 80%, rgba(42,161,152,0.08) 0%, transparent 50%),
           radial-gradient(circle at 80% 20%, rgba(42,161,152,0.05) 0%, transparent 50%);">
    </div>

    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold tracking-tight text-sol-cyan mb-8 text-center">LLM Comparator</h1>

        <div class="card mb-8">
            <div class="text-xs uppercase tracking-wider text-base-1 mb-3">Intro</div>
            <p class="text-sm text-base-01 leading-relaxed mb-3">
                Compare responses across multiple large language models with the same prompt set, then review side-by-side
                output, latency, and token usage.
            </p>
            <ul class="text-sm text-base-01 leading-relaxed list-disc pl-5 space-y-1">
                <li>You will be prompted for your API keys when you run a comparison, or <a href="#" class="text-sol-cyan hover:text-base-01 transition-colors" data-tab-target="security">enter them here now</a>.</li>
                <li>Conversations can be saved and loaded as JSON or as GitHub Gists</li>
                <li>Conversations saved as Gists can be shared as links, for example <a href="./llm_comparator.html?gist=735239bb7c9d2888ed9bd19015270de9" class="text-sol-cyan hover:text-base-01 transition-colors">the improve Python prompt from OpenAI</a>.
                </li>
            </ul>
        </div>

        <div class="flex flex-wrap justify-center gap-2 mb-6">
            <button class="app-tab-btn btn-primary text-sm" data-tab="comparator">Comparator</button>
            <button class="app-tab-btn btn-secondary text-sm" data-tab="security">API Keys and Data Security</button>
        </div>

        <div id="tab-comparator" class="app-tab">
            <div class="box-with-title mb-6">
                <div class="box-title">API Providers</div>
                <div class="space-y-4">
                    <div class="provider-item">
                        <div class="flex items-center gap-3 cursor-pointer">
                            <input type="checkbox" id="openai-provider" class="provider-checkbox checkbox" data-provider="openai">
                            <label for="openai-provider" class="cursor-pointer text-base-00 font-semibold">OpenAI</label>
                            <span class="key-indicator items-center gap-1.5 ml-auto text-[12px] text-sol-green" data-provider="openai" title="API key saved">
                                <span>●</span>
                                Key Saved
                            </span>
                            <button class="clear-key-button btn-danger text-xs px-2 py-1" data-provider="openai">Clear</button>
                        </div>
                        <div class="model-options ml-6 mt-3 pt-3 border-t border-base-1/20" id="openai-models">
                            <div class="mt-2 flex items-center gap-2">
                                <input type="text" id="openai-custom" placeholder="Model ID..." data-provider="openai" class="form-input flex-1">
                                <button id="openai-save-model" class="btn-success">Save</button>
                            </div>
                            <div class="text-xs text-base-00 uppercase tracking-wider mb-2 mt-5 pt-2 font-semibold">Saved models</div>
                            <div class="saved-models flex flex-col gap-1.5" id="openai-saved-models"></div>
                            <div class="flex items-center gap-2 py-1.5">
                                <input type="checkbox" id="openai-gpt5nano" class="checkbox" data-provider="openai" data-model="gpt-5-nano">
                                <label for="openai-gpt5nano" class="cursor-pointer text-base-01 text-[13px]">gpt-5-nano</label>
                            </div>
                        </div>
                    </div>

                    <div class="provider-item">
                        <div class="flex items-center gap-3 cursor-pointer">
                            <input type="checkbox" id="anthropic-provider" class="provider-checkbox checkbox" data-provider="anthropic">
                            <label for="anthropic-provider" class="cursor-pointer text-base-00 font-semibold">Anthropic</label>
                            <span class="key-indicator items-center gap-1.5 ml-auto text-[12px] text-sol-green" data-provider="anthropic" title="API key saved">
                                <span>●</span>
                                Key Saved
                            </span>
                            <button class="clear-key-button btn-danger text-xs px-2 py-1" data-provider="anthropic">Clear</button>
                        </div>
                        <div class="model-options ml-6 mt-3 pt-3 border-t border-base-1/20" id="anthropic-models">
                            <div class="mt-2 flex items-center gap-2">
                                <input type="text" id="anthropic-custom" placeholder="Model ID..." data-provider="anthropic" class="form-input flex-1">
                                <button id="anthropic-save-model" class="btn-success">Save</button>
                            </div>
                            <div class="text-xs text-base-00 uppercase tracking-wider mb-2 mt-5 pt-2 font-semibold">Saved models</div>
                            <div class="saved-models flex flex-col gap-1.5" id="anthropic-saved-models"></div>
                            <div class="flex items-center gap-2 py-1.5">
                                <input type="checkbox" id="anthropic-haiku3" class="checkbox" data-provider="anthropic" data-model="claude-3-haiku-20240307">
                                <label for="anthropic-haiku3" class="cursor-pointer text-base-01 text-[13px]">claude-3-haiku</label>
                            </div>
                            <div class="flex items-center gap-2 py-1.5">
                                <input type="checkbox" id="anthropic-haiku35" class="checkbox" data-provider="anthropic" data-model="claude-3-5-haiku-20241022">
                                <label for="anthropic-haiku35" class="cursor-pointer text-base-01 text-[13px]">claude-3.5-haiku</label>
                            </div>
                            <div class="flex items-center gap-2 py-1.5">
                                <input type="checkbox" id="anthropic-haiku45" class="checkbox" data-provider="anthropic" data-model="claude-haiku-4-5-20251001">
                                <label for="anthropic-haiku45" class="cursor-pointer text-base-01 text-[13px]">claude-4.5-haiku</label>
                            </div>
                        </div>
                    </div>

                    <div class="provider-item">
                        <div class="flex items-center gap-3 cursor-pointer">
                            <input type="checkbox" id="gemini-provider" class="provider-checkbox checkbox" data-provider="gemini">
                            <label for="gemini-provider" class="cursor-pointer text-base-00 font-semibold">Google Gemini</label>
                            <span class="key-indicator items-center gap-1.5 ml-auto text-[12px] text-sol-green" data-provider="gemini" title="API key saved">
                                <span>●</span>
                                Key Saved
                            </span>
                            <button class="clear-key-button btn-danger text-xs px-2 py-1" data-provider="gemini">Clear</button>
                        </div>
                        <div class="model-options ml-6 mt-3 pt-3 border-t border-base-1/20" id="gemini-models">
                            <div class="mt-2 flex items-center gap-2">
                                <input type="text" id="gemini-custom" placeholder="Model ID..." data-provider="gemini" class="form-input flex-1">
                                <button id="gemini-save-model" class="btn-success">Save</button>
                            </div>
                            <div class="text-xs text-base-00 uppercase tracking-wider mb-2 mt-5 pt-2 font-semibold">Saved models</div>
                            <div class="saved-models flex flex-col gap-1.5" id="gemini-saved-models"></div>
                            <div class="flex items-center gap-2 py-1.5">
                                <input type="checkbox" id="gemini-flash" class="checkbox" data-provider="gemini" data-model="gemini-2.5-flash-lite">
                                <label for="gemini-flash" class="cursor-pointer text-base-01 text-[13px]">gemini-2.5-flash-lite</label>
                            </div>
                            <div class="flex items-center gap-2 py-1.5">
                                <input type="checkbox" id="gemini-flash3" class="checkbox" data-provider="gemini" data-model="gemini-3-flash-preview">
                                <label for="gemini-flash3" class="cursor-pointer text-base-01 text-[13px]">gemini-3-flash-preview</label>
                            </div>
                        </div>
                    </div>

                    <div class="provider-item">
                        <div class="flex items-center gap-3 cursor-pointer">
                            <input type="checkbox" id="openrouter-provider" class="provider-checkbox checkbox" data-provider="openrouter">
                            <label for="openrouter-provider" class="cursor-pointer text-base-00 font-semibold">OpenRouter</label>
                            <span class="key-indicator items-center gap-1.5 ml-auto text-[12px] text-sol-green" data-provider="openrouter" title="API key saved">
                                <span>●</span>
                                Key Saved
                            </span>
                            <button class="clear-key-button btn-danger text-xs px-2 py-1" data-provider="openrouter">Clear</button>
                        </div>
                        <div class="model-options ml-6 mt-3 pt-3 border-t border-base-1/20" id="openrouter-models">
                            <div class="mt-2 space-y-2">
                                <label for="openrouter-model-search" class="block text-xs text-base-1 uppercase tracking-wider">Search</label>
                                <div class="flex flex-col sm:flex-row gap-2 sm:items-center">
                                    <input type="text" id="openrouter-model-search" placeholder="Search OpenRouter models..." class="form-input flex-1">
                                    <button id="openrouter-refresh-models" class="btn-secondary text-xs px-2 py-1">Refresh</button>
                                </div>
                                <div class="flex flex-wrap items-center gap-2 text-xs text-base-1">
                                    <span id="openrouter-models-last-updated">Not refreshed yet</span>
                                    <span id="openrouter-models-status" class="text-xs text-base-1"></span>
                                </div>
                                <div id="openrouter-model-results" class="mt-1 max-h-64 overflow-y-auto pr-1 space-y-2"></div>
                            </div>
                            <div class="mt-3 flex items-center gap-2">
                                <input type="text" id="openrouter-custom" placeholder="Model ID (e.g., deepseek/deepseek-v3.2, x-ai/grok-code-fast-1)..." data-provider="openrouter" class="form-input flex-1">
                                <button id="openrouter-save-model" class="btn-success">Save</button>
                            </div>
                            <div class="text-xs text-base-00 uppercase tracking-wider mb-2 mt-5 pt-2 font-semibold">Saved models</div>
                            <div class="saved-models flex flex-col gap-1.5" id="openrouter-saved-models"></div>
                        </div>
                    </div>

                    <div id="customProvidersContainer" class="space-y-4"></div>
                    <button id="addCustomProviderButton" class="w-full border border-dashed border-base-1/30 p-4 text-center text-base-1 cursor-pointer transition-all duration-150 hover:border-sol-cyan hover:text-sol-cyan hover:bg-base-2 rounded">+ Add Custom or Local Provider</button>
                </div>
            </div>

            <div class="box-with-title mb-6">
                <div class="box-title">Import/Export</div>
                <div class="flex flex-wrap gap-2">
                    <button id="downloadPrompts" class="btn-secondary">Download JSON</button>
                    <button id="uploadPrompts" class="btn-secondary">Upload JSON</button>
                    <button id="loadFromGist" class="btn-secondary">Load from Gist</button>
                    <button id="saveToGist" class="btn-secondary">Save to Gist</button>
                </div>
                <input type="file" id="uploadPromptsFile" accept="application/json" class="hidden">
                <div id="gistLoader" class="hidden mt-4 pt-4 border-t border-base-1/20 flex flex-col gap-2">
                    <label for="gistInput" class="text-xs text-base-1 uppercase tracking-wider">Gist URL or ID</label>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <input id="gistInput" type="text" placeholder="https://gist.github.com/username/abcdef... or gist id" class="form-input flex-1">
                        <button id="fetchGistButton" class="btn-primary">Fetch</button>
                    </div>
                    <div id="gistStatus" class="text-xs text-base-1"></div>
                </div>
                <div id="gistSavePanel" class="slide-panel mt-4 pt-4 border-t border-base-1/20 flex flex-col gap-3">
                    <div class="text-xs text-base-1 uppercase tracking-wider">GitHub Personal Access Token</div>
                    <div class="text-sm text-base-01 leading-relaxed space-y-2">
                        <p>Create a token to save private gists:</p>
                        <ol class="list-decimal list-inside space-y-1">
                            <li>GitHub → Settings → Developer settings → Personal access tokens → Fine-grained tokens.</li>
                            <li>Generate a new token, add a note + expiration.</li>
                            <li>Under Permissions, search for and select the <span class="text-base-00 font-semibold">Gists</span> permission with read and write access. </li>
                            <li>Copy the token and paste it below.</li>
                        </ol>
                        <p class="text-[13px] text-base-1">Stored locally in this browser.</p>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <input id="gistTokenInput" type="password" placeholder="ghp_..." class="form-input flex-1">
                        <button id="saveGistTokenButton" class="btn-primary">Save Token &amp; Create Gist</button>
                    </div>
                    <div id="gistSaveStatus" class="text-xs text-base-1"></div>
                </div>
                <div id="gistSaveResult" class="slide-panel mt-4 pt-4 border-t border-base-1/20 flex flex-col gap-3">
                    <div class="text-xs text-base-1 uppercase tracking-wider">Gist Created</div>
                    <div class="flex flex-col gap-3 text-sm text-base-01">
                        <div class="flex flex-col sm:flex-row sm:items-center gap-2">
                            <a id="gistResultLink" href="#" target="_blank" rel="noopener" class="text-sol-cyan hover:text-base-01 transition-colors break-all">Gist link</a>
                            <button id="copyGistLink" class="btn-secondary text-xs">Copy</button>
                        </div>
                        <div class="flex flex-col sm:flex-row sm:items-center gap-2">
                            <a id="gistLoadLink" href="#" target="_blank" rel="noopener" class="text-sol-cyan hover:text-base-01 transition-colors break-all">Open this page with gist loaded</a>
                            <button id="copyGistLoadLink" class="btn-secondary text-xs">Copy</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="box-with-title mb-6">
                <div class="box-title">System Prompt</div>
                <textarea id="systemPrompt" placeholder="Enter your system prompt here..." class="form-input resize-y min-h-[100px]">You are a helpful assistant.</textarea>
            </div>

            <!-- Conversation Rounds Section -->
            <div class="box-with-title mb-6">
                <div class="box-title">Conversation Rounds</div>
                <div class="flex justify-end mb-4">
                    <button id="addConversationRound" class="btn-secondary">+ Add Round</button>
                </div>
                <div id="conversationRoundsContainer" class="space-y-3"></div>
            </div>

            <div class="flex gap-4 mb-8">
                <button id="sendButton" class="btn-primary flex-1 py-3 text-sm disabled:opacity-40 disabled:cursor-not-allowed">Send to APIs</button>
            </div>

            <div class="box-with-title">
                <div class="box-title">Results</div>
                <div class="grid grid-cols-1 md:grid-cols-[repeat(auto-fit,minmax(300px,1fr))] gap-5" id="resultsGrid"></div>
            </div>
        </div>

        <div id="tab-security" class="app-tab hidden">
            <div class="box-with-title mb-6">
                <div class="box-title">Data Security</div>
                <div class="space-y-3 text-sm text-base-01 leading-relaxed">
                    <p>All prompts, responses, and API keys are stored in your browser's local storage on this device. There is no server-side storage for this tool.</p>
                    <p>API requests are sent directly from your browser to each LLM provider. There is no intermediary service adding extra security or filtering between you and the provider.</p>
                </div>
                <div class="mt-4 border border-base-1/20 p-4 text-sm text-base-01 bg-base-2 rounded">
                    <div class="text-base-00 font-semibold uppercase tracking-wider text-xs mb-2">Local Storage Keys</div>
                    <div class="grid gap-1 sm:grid-cols-2 text-[13px]">
                        <div>OpenAI → openai_api_key</div>
                        <div>Anthropic → anthropic_api_key</div>
                        <div>Gemini → gemini_api_key</div>
                        <div>OpenRouter → openrouter_api_key</div>
                        <div>OpenRouter Models → openrouter_models_cache</div>
                        <div>Custom Providers → custom_providers</div>
                        <div>Selected Models → selected_models_by_provider</div>
                        <div>Saved Models → *_saved_models</div>
                        <div>Prompts → saved_system_prompt / saved_conversation_rounds</div>
                        <div>GitHub PAT → github_pat</div>
                    </div>
                </div>
            </div>

            <div class="box-with-title">
                <div class="box-title">Stored API Keys</div>
                <div id="securityKeyManager" class="space-y-3"></div>
            </div>
        </div>
    </div>

    <script>
        const BUILTIN_PROVIDERS = ['openai', 'anthropic', 'gemini', 'openrouter'];
        const API_CONFIGS = {
            openai: {
                name: 'OpenAI',
                storageKey: 'openai_api_key',
                endpoint: 'https://api.openai.com/v1/chat/completions',
                type: 'openai',
                requiresApiKey: true,
                promptForKey: true
            },
            anthropic: {
                name: 'Anthropic',
                storageKey: 'anthropic_api_key',
                endpoint: 'https://api.anthropic.com/v1/messages',
                type: 'anthropic',
                requiresApiKey: true,
                promptForKey: true
            },
            gemini: {
                name: 'Gemini',
                storageKey: 'gemini_api_key',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/models',
                type: 'gemini',
                requiresApiKey: true,
                promptForKey: true
            },
            openrouter: {
                name: 'OpenRouter',
                storageKey: 'openrouter_api_key',
                endpoint: 'https://openrouter.ai/api/v1/chat/completions',
                type: 'openrouter',
                requiresApiKey: true,
                promptForKey: true
            }
        };
        const SAVED_MODELS_KEYS = {
            openai: 'openai_saved_models',
            anthropic: 'anthropic_saved_models',
            gemini: 'gemini_saved_models',
            openrouter: 'openrouter_saved_models'
        };
        const CUSTOM_PROVIDERS_STORAGE_KEY = 'custom_providers';
        let customProviders = [];
        const SELECTED_MODELS_STORAGE_KEY = 'selected_models_by_provider';
        let selectedModelsState = {};
        const GITHUB_PAT_STORAGE_KEY = 'github_pat';
        const GIST_EXPORT_FILENAME = 'prompts.json';
        const OPENROUTER_MODELS_CACHE_KEY = 'openrouter_models_cache';
        const OPENROUTER_MODEL_RESULT_LIMIT = 40;
        let openRouterModelCache = { cachedAt: '', models: [] };
        let openRouterModelFetchInFlight = false;
        const OLLAMA_CORS_HELP_URL = 'https://docs.ollama.com/faq#how-can-i-allow-additional-web-origins-to-access-ollama';

        function loadSelectedModelsState() {
            selectedModelsState = {};
            const raw = localStorage.getItem(SELECTED_MODELS_STORAGE_KEY);
            if (!raw) return;

            try {
                const parsed = JSON.parse(raw);
                if (parsed && typeof parsed === 'object') {
                    Object.entries(parsed).forEach(([provider, models]) => {
                        if (Array.isArray(models)) {
                            const cleaned = models
                                .filter(m => typeof m === 'string' && m.trim())
                                .map(m => m.trim());
                            if (cleaned.length) {
                                selectedModelsState[provider] = cleaned;
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to parse selected models state:', error);
            }
        }

        function persistSelectedModelsState() {
            localStorage.setItem(SELECTED_MODELS_STORAGE_KEY, JSON.stringify(selectedModelsState));
        }

        function loadOpenRouterModelCache() {
            openRouterModelCache = { cachedAt: '', models: [] };
            const raw = localStorage.getItem(OPENROUTER_MODELS_CACHE_KEY);
            if (!raw) return;

            try {
                const parsed = JSON.parse(raw);
                if (parsed && typeof parsed === 'object') {
                    const cachedAt = typeof parsed.cachedAt === 'string' ? parsed.cachedAt : '';
                    const models = Array.isArray(parsed.models) ? parsed.models : [];
                    openRouterModelCache = { cachedAt, models };
                }
            } catch (error) {
                console.error('Failed to parse OpenRouter model cache:', error);
            }
        }

        function updateOpenRouterModelCacheInfo() {
            const label = document.getElementById('openrouter-models-last-updated');
            if (!label) return;
            if (!openRouterModelCache.cachedAt) {
                label.textContent = 'Not refreshed yet';
                return;
            }
            const parsedDate = new Date(openRouterModelCache.cachedAt);
            if (Number.isNaN(parsedDate.getTime())) {
                label.textContent = 'Last refreshed: unknown';
                return;
            }
            label.textContent = `Last refreshed: ${parsedDate.toLocaleString()}`;
        }

        function setOpenRouterModelStatus(message = '', cls = 'text-base-1') {
            const el = document.getElementById('openrouter-models-status');
            if (!el) return;
            el.className = `text-xs ${cls}`;
            el.textContent = message;
        }

        function formatOpenRouterPrice(value) {
            if (value === null || value === undefined || value === '') {
                return 'n/a';
            }
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return 'n/a';
            }
            const perMillion = numeric * 1000000;
            return `$${perMillion.toFixed(2)} per million tokens`;
        }

        function buildOpenRouterModelResult(model, onSelect) {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'model-search-item';
            button.addEventListener('click', () => onSelect(model));

            const idLine = document.createElement('div');
            idLine.className = 'text-sm text-base-00 font-semibold';
            idLine.textContent = model.id || 'unknown-id';

            const nameLine = document.createElement('div');
            nameLine.className = 'text-[12px] text-base-01';
            nameLine.textContent = model.name || 'Unnamed model';

            const descLine = document.createElement('div');
            descLine.className = 'model-search-description';
            descLine.textContent = model.description || 'No description available.';

            const metaLine = document.createElement('div');
            metaLine.className = 'model-search-meta';
            const promptPrice = formatOpenRouterPrice(model.pricing?.prompt);
            const completionPrice = formatOpenRouterPrice(model.pricing?.completion);
            const contextLength = model.context_length ? Number(model.context_length).toLocaleString() : 'n/a';
            metaLine.textContent = `Prompt: ${promptPrice} · Completion: ${completionPrice} · Context: ${contextLength}`;

            button.appendChild(idLine);
            button.appendChild(nameLine);
            button.appendChild(descLine);
            button.appendChild(metaLine);

            return button;
        }

        function renderOpenRouterModelResults() {
            const results = document.getElementById('openrouter-model-results');
            const searchInput = document.getElementById('openrouter-model-search');
            const modelInput = document.getElementById('openrouter-custom');
            if (!results || !searchInput) return;

            results.innerHTML = '';
            if (!openRouterModelCache.models.length) {
                const empty = document.createElement('div');
                empty.className = 'text-[12px] text-base-1';
                empty.textContent = 'No cached models yet. Add an OpenRouter key and refresh.';
                results.appendChild(empty);
                return;
            }

            const query = searchInput.value.trim().toLowerCase();
            if (!query) {
                const hint = document.createElement('div');
                hint.className = 'text-[12px] text-base-1';
                hint.textContent = 'Start typing to search the cached model list.';
                results.appendChild(hint);
                return;
            }

            const matches = openRouterModelCache.models.filter(model => {
                const id = (model.id || '').toLowerCase();
                const name = (model.name || '').toLowerCase();
                const description = (model.description || '').toLowerCase();
                return id.includes(query) || name.includes(query) || description.includes(query);
            });

            if (!matches.length) {
                const empty = document.createElement('div');
                empty.className = 'text-[12px] text-base-1';
                empty.textContent = 'No matching models found.';
                results.appendChild(empty);
                return;
            }

            const limited = matches.slice(0, OPENROUTER_MODEL_RESULT_LIMIT);
            limited.forEach(model => {
                const card = buildOpenRouterModelResult(model, selected => {
                    if (modelInput) {
                        modelInput.value = selected.id || '';
                        modelInput.focus();
                    }
                });
                results.appendChild(card);
            });

            if (matches.length > limited.length) {
                const more = document.createElement('div');
                more.className = 'text-[12px] text-base-1';
                more.textContent = `Showing ${limited.length} of ${matches.length} matches. Refine your search to narrow results.`;
                results.appendChild(more);
            }
        }

        async function refreshOpenRouterModelCache() {
            if (openRouterModelFetchInFlight) return;
            const apiKey = getStoredApiKey('openrouter');
            if (!apiKey) {
                setOpenRouterModelStatus('Add an OpenRouter API key to refresh.', 'text-sol-red');
                return;
            }

            const refreshButton = document.getElementById('openrouter-refresh-models');
            openRouterModelFetchInFlight = true;
            if (refreshButton) {
                refreshButton.disabled = true;
            }
            setOpenRouterModelStatus('Refreshing models...', 'text-base-1');

            try {
                const response = await fetch('https://openrouter.ai/api/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });
                if (!response.ok) {
                    throw new Error(`OpenRouter models request failed (${response.status})`);
                }
                const body = await response.json();
                const models = Array.isArray(body?.data) ? body.data : [];
                openRouterModelCache = { cachedAt: new Date().toISOString(), models };
                localStorage.setItem(OPENROUTER_MODELS_CACHE_KEY, JSON.stringify(openRouterModelCache));
                updateOpenRouterModelCacheInfo();
                renderOpenRouterModelResults();
                setOpenRouterModelStatus(`Loaded ${models.length} models.`, 'text-sol-green');
            } catch (error) {
                console.error('Failed to refresh OpenRouter models:', error);
                setOpenRouterModelStatus('Failed to refresh models.', 'text-sol-red');
            } finally {
                openRouterModelFetchInFlight = false;
                if (refreshButton) {
                    refreshButton.disabled = false;
                }
            }
        }

        function loadCustomProvidersFromStorage() {
            customProviders = [];
            const raw = localStorage.getItem(CUSTOM_PROVIDERS_STORAGE_KEY);
            if (!raw) return;

            try {
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed)) {
                    customProviders = parsed
                        .map(item => ({
                            id: typeof item.id === 'string' ? item.id : generateCustomProviderId(),
                            name: typeof item.name === 'string' ? item.name : '',
                            endpoint: typeof item.endpoint === 'string' ? item.endpoint : '',
                            apiKey: typeof item.apiKey === 'string' ? item.apiKey : '',
                            models: Array.isArray(item.models) ? item.models.filter(m => typeof m === 'string' && m.trim()).map(m => m.trim()) : []
                        }));
                }
            } catch (error) {
                console.error('Failed to parse custom providers:', error);
            }
        }

        function persistCustomProviders() {
            localStorage.setItem(CUSTOM_PROVIDERS_STORAGE_KEY, JSON.stringify(customProviders));
        }

        function syncCustomProvidersToConfigs() {
            // remove stale custom configs
            Object.keys(API_CONFIGS)
                .filter(key => API_CONFIGS[key].custom)
                .forEach(key => delete API_CONFIGS[key]);

            customProviders.forEach(provider => {
                API_CONFIGS[provider.id] = {
                    name: provider.name?.trim() || 'Custom Provider',
                    endpoint: provider.endpoint || '',
                    type: 'openai-compatible',
                    requiresApiKey: false,
                    promptForKey: false,
                    custom: true
                };
            });
        }

        function getAllProviderIds() {
            return [...BUILTIN_PROVIDERS, ...customProviders.map(p => p.id)];
        }

        function getCustomProvider(providerId) {
            return customProviders.find(p => p.id === providerId);
        }

        function generateCustomProviderId() {
            const randomId = (window.crypto && typeof window.crypto.randomUUID === 'function')
                ? window.crypto.randomUUID()
                : `${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            return `custom-${randomId}`;
        }

        function updateCustomProvider(providerId, changes = {}) {
            const provider = getCustomProvider(providerId);
            if (!provider) return;
            Object.assign(provider, changes);
            persistCustomProviders();
            syncCustomProvidersToConfigs();
        }

        function getProviderDisplayName(providerId) {
            const config = API_CONFIGS[providerId];
            if (config && config.name) return config.name;
            const custom = getCustomProvider(providerId);
            return custom?.name?.trim() || 'Custom Provider';
        }

        function getProviderStorageLabel(providerId) {
            const config = API_CONFIGS[providerId];
            if (config && config.storageKey) {
                return config.storageKey;
            }
            const custom = getCustomProvider(providerId);
            if (custom) {
                return CUSTOM_PROVIDERS_STORAGE_KEY;
            }
            return 'not stored';
        }

        function renderCustomProviders() {
            const container = document.getElementById('customProvidersContainer');
            if (!container) return;

            syncCustomProvidersToConfigs();

            container.innerHTML = '';

            if (!customProviders.length) {
                const empty = document.createElement('div');
                empty.className = 'p-3 border border-base-1/20 text-sm text-base-1 bg-base-2 rounded';
                empty.textContent = 'No custom providers yet. Add one to point at a local or self-hosted OpenAI-compatible API.';
                container.appendChild(empty);
            }

            customProviders.forEach(provider => {
                const card = document.createElement('div');
                card.className = 'provider-item';
                card.dataset.providerId = provider.id;

                const checkboxId = `${provider.id}-provider`;
                const nameValue = provider.name || '';
                const endpointValue = provider.endpoint || '';
                const apiKeyValue = provider.apiKey || '';
                const labelText = nameValue.trim() || 'Custom Provider';

                card.innerHTML = `
                    <div class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="${checkboxId}" class="provider-checkbox checkbox" data-provider="${provider.id}">
                        <label for="${checkboxId}" class="cursor-pointer text-base-00 font-semibold" data-provider-label="${provider.id}">Custom Provider</label>
                        <span class="key-indicator items-center gap-1.5 ml-auto text-[12px] text-sol-green" data-provider="${provider.id}" title="API key saved">
                            <span>●</span>
                            Key Saved
                        </span>
                        <button class="clear-key-button btn-danger text-xs px-2 py-1" data-provider="${provider.id}">Clear</button>
                    </div>
                    <div class="grid sm:grid-cols-2 gap-3 mt-3">
                        <div class="space-y-1.5">
                            <label class="text-xs text-base-1 uppercase tracking-wider">Name (optional)</label>
                            <input type="text" data-provider-id="${provider.id}" data-field="name" class="form-input" placeholder="Custom Provider">
                        </div>
                        <div class="space-y-1.5">
                            <label class="text-xs text-base-1 uppercase tracking-wider">API Endpoint</label>
                            <input type="text" data-provider-id="${provider.id}" data-field="endpoint" class="form-input" placeholder="http://localhost:11434/v1">
                        </div>
                        <div class="sm:col-span-2 space-y-1.5">
                            <label class="text-xs text-base-1 uppercase tracking-wider">API Key (optional)</label>
                            <input type="password" data-provider-id="${provider.id}" data-field="apiKey" class="form-input" placeholder="Bearer token for this endpoint">
                            <p class="text-xs text-base-1 mt-1">Stored locally and sent as a Bearer token only if provided.</p>
                        </div>
                    </div>
                    <div class="model-options ml-0 sm:ml-6 mt-3 pt-3 border-t border-base-1/20" id="${provider.id}-models">
                        <div class="mt-2 flex items-center gap-2">
                            <input type="text" id="${provider.id}-custom" placeholder="Model name (e.g., llama3.1:latest)..." data-provider="${provider.id}" class="form-input flex-1">
                            <button id="${provider.id}-save-model" class="btn-success">Save</button>
                        </div>
                        <div class="text-xs text-base-00 uppercase tracking-wider mb-2 mt-5 pt-2 font-semibold">Saved models</div>
                        <div class="saved-models flex flex-col gap-1.5" id="${provider.id}-saved-models"></div>
                    </div>
                `;

                container.appendChild(card);

                const nameInput = card.querySelector('input[data-field="name"]');
                const endpointInput = card.querySelector('input[data-field="endpoint"]');
                const apiKeyInput = card.querySelector('input[data-field="apiKey"]');
                const nameLabel = card.querySelector(`[data-provider-label="${provider.id}"]`);

                if (nameLabel) {
                    nameLabel.textContent = labelText;
                }

                if (nameInput) {
                    nameInput.value = nameValue;
                }

                if (endpointInput) {
                    endpointInput.value = endpointValue;
                }

                if (apiKeyInput) {
                    apiKeyInput.value = apiKeyValue;
                }

                if (nameInput) {
                    nameInput.addEventListener('input', (event) => {
                        const value = event.target.value || '';
                        updateCustomProvider(provider.id, { name: value });
                        if (nameLabel) {
                            nameLabel.textContent = value.trim() || 'Custom Provider';
                        }
                    });
                }

                if (endpointInput) {
                    endpointInput.addEventListener('input', (event) => {
                        updateCustomProvider(provider.id, { endpoint: event.target.value || '' });
                    });
                }

                if (apiKeyInput) {
                    apiKeyInput.addEventListener('input', (event) => {
                        updateCustomProvider(provider.id, { apiKey: event.target.value || '' });
                        updateKeyIndicator(provider.id);
                    });
                }

                attachSaveButtonHandler(provider.id);
            });

            setupProviderCheckboxes();
            renderAllSavedModels();
            applySelectedModelsToCheckboxes();
            updateAllKeyIndicators();
            if (document.getElementById('tab-security')?.classList.contains('hidden') === false) {
                renderSecurityKeyManager();
            }
        }

        function addCustomProvider() {
            const id = generateCustomProviderId();
            customProviders.push({
                id,
                name: '',
                endpoint: '',
                apiKey: '',
                models: []
            });
            persistCustomProviders();
            syncCustomProvidersToConfigs();
            renderCustomProviders();
            const nameInput = document.querySelector(`input[data-provider-id="${id}"][data-field="name"]`);
            if (nameInput) {
                nameInput.focus();
            }
        }

        function isModelSelected(provider, model) {
            const trimmed = (model || '').trim();
            if (!provider || !trimmed) return false;
            const list = selectedModelsState[provider] || [];
            return list.some(item => item.toLowerCase() === trimmed.toLowerCase());
        }

        function setModelSelected(provider, model, isSelected) {
            const trimmed = (model || '').trim();
            if (!provider || !trimmed) return;

            if (!selectedModelsState[provider]) {
                selectedModelsState[provider] = [];
            }

            const list = selectedModelsState[provider];
            const existingIndex = list.findIndex(item => item.toLowerCase() === trimmed.toLowerCase());

            if (isSelected) {
                if (existingIndex === -1) {
                    list.push(trimmed);
                }
            } else if (existingIndex !== -1) {
                list.splice(existingIndex, 1);
            }

            if (selectedModelsState[provider] && selectedModelsState[provider].length === 0) {
                delete selectedModelsState[provider];
            }

            persistSelectedModelsState();
        }

        function applySelectedModelsToCheckboxes() {
            document.querySelectorAll('input[type="checkbox"][data-provider][data-model]').forEach(cb => {
                const provider = cb.dataset.provider;
                const model = cb.dataset.model;
                cb.checked = isModelSelected(provider, model);
            });
        }

        loadSelectedModelsState();
        loadCustomProvidersFromStorage();
        syncCustomProvidersToConfigs();

        // Pricing data cache
        let pricingData = [];

        // Fetch pricing data
        async function fetchPricingData() {
            try {
                const response = await fetch('https://www.llm-prices.com/current-v1.json');
                const data = await response.json();
                pricingData = data.prices || [];
                console.log('Pricing data loaded:', pricingData.length, 'models');
            } catch (error) {
                console.error('Failed to load pricing data:', error);
                pricingData = [];
            }
        }

        function getSavedModels(provider) {
            const custom = getCustomProvider(provider);
            if (custom) {
                return (Array.isArray(custom.models) ? custom.models : [])
                    .filter(item => typeof item === 'string' && item.trim())
                    .map(item => item.trim());
            }

            const key = SAVED_MODELS_KEYS[provider];
            if (!key) return [];
            const saved = localStorage.getItem(key);
            if (!saved) return [];

            try {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed)) {
                    return parsed
                        .filter(item => typeof item === 'string' && item.trim())
                        .map(item => item.trim());
                }
            } catch (error) {
                console.error(`Failed to parse saved ${provider} models:`, error);
            }

            return [];
        }

        function persistSavedModels(provider, models) {
            const custom = getCustomProvider(provider);
            if (custom) {
                custom.models = models;
                persistCustomProviders();
                return;
            }

            const key = SAVED_MODELS_KEYS[provider];
            if (!key) return;
            localStorage.setItem(key, JSON.stringify(models));
        }

        function renderSavedModels(provider) {
            const container = document.getElementById(`${provider}-saved-models`);
            if (!container) return;

            const previouslyChecked = new Set(
                Array.from(container.querySelectorAll('input[type=\"checkbox\"][data-model]'))
                    .filter(cb => cb.checked)
                    .map(cb => cb.dataset.model)
            );

            container.innerHTML = '';
            const models = getSavedModels(provider);

            if (models.length === 0) {
                container.innerHTML = '<div class="text-base-1 text-[13px]">No saved models yet</div>';
                return;
            }

            models.forEach((model, index) => {
                const checkboxId = `${provider}-saved-${index}-${model.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`;
                const wrapper = document.createElement('div');
                wrapper.className = 'flex items-center gap-2 py-1.5 w-full';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = checkboxId;
                checkbox.className = 'checkbox';
                checkbox.dataset.provider = provider;
                checkbox.dataset.model = model;
                checkbox.checked = previouslyChecked.has(model) || isModelSelected(provider, model);

                const label = document.createElement('label');
                label.setAttribute('for', checkboxId);
                label.className = 'cursor-pointer text-base-01 text-[13px]';
                label.textContent = model;

                const deleteButton = document.createElement('button');
                deleteButton.className = 'btn-danger text-xs px-2 py-1 ml-auto';
                deleteButton.textContent = '✕';
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    removeSavedModel(provider, model);
                });

                wrapper.appendChild(checkbox);
                wrapper.appendChild(label);
                wrapper.appendChild(deleteButton);
                container.appendChild(wrapper);
            });
        }

        function renderAllSavedModels() {
            getAllProviderIds().forEach(renderSavedModels);
        }

        function addSavedModel(provider, model) {
            const trimmed = (model || '').trim();
            const isCustom = Boolean(getCustomProvider(provider));
            if (!trimmed || (!isCustom && !SAVED_MODELS_KEYS[provider])) return false;

            const savedModels = getSavedModels(provider);
            const exists = savedModels.some(m => m.toLowerCase() === trimmed.toLowerCase());
            if (exists) return false;

            savedModels.push(trimmed);
            persistSavedModels(provider, savedModels);
            renderSavedModels(provider);
            return true;
        }

        function removeSavedModel(provider, model) {
            const savedModels = getSavedModels(provider);
            const filtered = savedModels.filter(m => m.toLowerCase() !== (model || '').toLowerCase());
            persistSavedModels(provider, filtered);
            setModelSelected(provider, model, false);
            renderSavedModels(provider);
        }

        // Count tokens using gpt-tokenizer
        function countTokens(text) {
            try {
                const encoded = GPTTokenizer_o200k_base.encode(text);
                return encoded.length;
            } catch (error) {
                console.error('Token counting error:', error);
                return 0;
            }
        }

        function getOpenRouterPricing(modelName) {
            if (!openRouterModelCache?.models?.length) return null;
            const normalized = (modelName || '').toLowerCase();
            if (!normalized) return null;

            let match = openRouterModelCache.models.find(model => {
                const id = (model.id || '').toLowerCase();
                return id === normalized;
            });

            if (!match) {
                match = openRouterModelCache.models.find(model => {
                    const id = (model.id || '').toLowerCase();
                    const name = (model.name || '').toLowerCase();
                    return id.includes(normalized) || normalized.includes(id) || name.includes(normalized);
                });
            }

            if (!match || !match.pricing) return null;

            const promptPrice = Number(match.pricing.prompt);
            const completionPrice = Number(match.pricing.completion);

            return {
                input: Number.isFinite(promptPrice) ? promptPrice * 1000000 : 0,
                output: Number.isFinite(completionPrice) ? completionPrice * 1000000 : 0
            };
        }

        function getPricingSource(provider) {
            if (provider === 'openrouter') {
                return {
                    href: 'https://openrouter.ai',
                    label: 'openrouter.ai'
                };
            }
            return {
                href: 'https://www.llm-prices.com',
                label: 'llm-prices.com'
            };
        }

        function buildPricingSourceHTML(provider) {
            const source = getPricingSource(provider);
            return `
                <p class="text-base-1 mt-2 text-[12px]">
                    Pricing Source: <a class="underline hover:text-base-00" href="${source.href}" target="_blank" rel="noopener noreferrer">${source.label}</a>
                </p>
            `;
        }

        // Get pricing for a model
        function getModelPricing(provider, modelName) {
            if (provider === 'openrouter') {
                return getOpenRouterPricing(modelName);
            }

            if (!pricingData || !Array.isArray(pricingData) || pricingData.length === 0) return null;

            // Normalize model name for matching
            const normalizedModel = modelName.toLowerCase();
            
            // Search through pricing data
            for (const item of pricingData) {
                const itemModel = (item.id || '').toLowerCase();
                const itemVendor = (item.vendor || '').toLowerCase();
                
                // Check if model matches
                if (itemModel.includes(normalizedModel) || normalizedModel.includes(itemModel)) {
                    // For some providers, also check vendor name
                    if (provider === 'anthropic' && itemVendor === 'anthropic') {
                        return item;
                    } else if (provider === 'openai' && itemVendor === 'openai') {
                        return item;
                    } else if (provider === 'gemini' && itemVendor === 'google') {
                        return item;
                    }
                }
            }
            
            return null;
        }

        // Calculate and format pricing
        function calculatePricing(provider, model, inputTokens, outputTokens) {
            const pricing = getModelPricing(provider, model);
            
            if (!pricing) {
                return {
                    inputPrice: 'Unknown',
                    outputPrice: 'Unknown',
                    totalPrice: 'Unknown',
                    isUnknown: true
                };
            }

            // Pricing is typically per million tokens
            const inputPrice = (inputTokens / 1000000) * (pricing.input || 0);
            const outputPrice = (outputTokens / 1000000) * (pricing.output || 0);
            const totalPrice = inputPrice + outputPrice;

            return {
                inputPrice: `$${inputPrice.toFixed(7)}`,
                outputPrice: `$${outputPrice.toFixed(7)}`,
                totalPrice: `$${totalPrice.toFixed(7)}`,
                isUnknown: false
            };
        }

        // Load pricing data on page load
        fetchPricingData();

        // Load saved prompts and conversation rounds on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedSystemPrompt = localStorage.getItem('saved_system_prompt');
            const savedConversationRounds = localStorage.getItem('saved_conversation_rounds');
            
            if (savedSystemPrompt) {
                document.getElementById('systemPrompt').value = savedSystemPrompt;
            }
            
            // Load saved conversation rounds
            if (savedConversationRounds) {
                try {
                    const rounds = JSON.parse(savedConversationRounds);
                    if (Array.isArray(rounds)) {
                        rounds.forEach(round => {
                            addConversationRound(round.role, round.message, false);
                        });
                    }
                } catch (error) {
                    console.error('Failed to parse conversation rounds:', error);
                }
            }

            renderCustomProviders();
            getAllProviderIds().forEach(attachSaveButtonHandler);
            setupAppTabs();
            loadOpenRouterModelCache();
            updateOpenRouterModelCacheInfo();
            renderOpenRouterModelResults();

            const openRouterSearchInput = document.getElementById('openrouter-model-search');
            if (openRouterSearchInput) {
                openRouterSearchInput.addEventListener('input', renderOpenRouterModelResults);
            }

            const openRouterRefreshButton = document.getElementById('openrouter-refresh-models');
            if (openRouterRefreshButton) {
                openRouterRefreshButton.addEventListener('click', () => refreshOpenRouterModelCache());
            }

            if (getStoredApiKey('openrouter') && !openRouterModelCache.models.length) {
                refreshOpenRouterModelCache();
            }

            const params = new URLSearchParams(window.location.search);
            const gistParam = extractGistId(params.get('gist') || '');
            if (gistParam) {
                if (gistLoader) {
                    gistLoader.classList.remove('hidden');
                }
                if (gistInput) {
                    gistInput.value = gistParam;
                }
                setGistStatus('Loading gist...', 'text-base-1');
                fetchGistAndImport(gistParam, setGistStatus).then(success => {
                    if (success) {
                        updateUrlWithGistId(gistParam);
                    } else {
                        updateUrlWithGistId('');
                    }
                });
            }
        });

        function setupAppTabs() {
            const tabButtons = document.querySelectorAll('.app-tab-btn');
            const tabs = document.querySelectorAll('.app-tab');
            if (!tabButtons.length || !tabs.length) return;

            const setActiveTab = (tabId) => {
                tabs.forEach(tab => {
                    tab.classList.toggle('hidden', tab.id !== `tab-${tabId}`);
                });
                tabButtons.forEach(button => {
                    const active = button.dataset.tab === tabId;
                    button.className = `app-tab-btn ${active ? 'btn-primary' : 'btn-secondary'} text-sm`;
                });
                if (tabId === 'security') {
                    renderSecurityKeyManager();
                }
            };

            tabButtons.forEach(button => {
                button.addEventListener('click', () => setActiveTab(button.dataset.tab));
            });

            document.querySelectorAll('[data-tab-target]').forEach(link => {
                link.addEventListener('click', (event) => {
                    event.preventDefault();
                    setActiveTab(link.dataset.tabTarget);
                });
            });

            setActiveTab('comparator');
        }

        // Function to create a conversation round element
        function createConversationRoundElement(roundId, role, message) {
            const roundElement = document.createElement('div');
            roundElement.className = 'border-l-[3px] border-sol-cyan p-3 bg-base-2 rounded';
            roundElement.dataset.roundId = roundId;

            roundElement.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center gap-2">
                        <span class="text-sol-cyan text-sm font-semibold">${role === 'user' ? '→' : '←'}</span>
                        <select class="bg-base-3 border border-base-1/20 text-base-00 px-2 py-1 text-xs uppercase tracking-wider cursor-pointer outline-none focus:border-sol-cyan focus:ring-[3px] focus:ring-sol-cyan/20 rounded" data-round-id="${roundId}">
                            <option value="user" ${role === 'user' ? 'selected' : ''}>User</option>
                            <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>Assistant</option>
                        </select>
                    </div>
                    <button class="btn-danger text-xs px-2 py-1" data-round-id="${roundId}">Delete</button>
                </div>
                <textarea class="form-input resize-y min-h-[80px]" placeholder="Enter message content..." data-round-id="${roundId}">${message || ''}</textarea>
            `;

            return roundElement;
        }

        // Function to add a conversation round
        function addConversationRound(role = 'user', message = '', saveToStorage = true) {
            const container = document.getElementById('conversationRoundsContainer');
            const roundId = `round-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            
            const roundElement = createConversationRoundElement(roundId, role, message);
            container.appendChild(roundElement);
            
            // Add event listeners for the new elements
            const selectElement = roundElement.querySelector('select');
            const deleteButton = roundElement.querySelector('button');
            const textareaElement = roundElement.querySelector('textarea');

            const handleRoundChange = () => {
                markPromptsModified();
                saveConversationRounds();
            };
            
            selectElement.addEventListener('change', handleRoundChange);
            textareaElement.addEventListener('input', handleRoundChange);
            deleteButton.addEventListener('click', () => {
                roundElement.remove();
                handleRoundChange();
            });
            
            if (saveToStorage) {
                handleRoundChange();
            }
            return roundElement;
        }

        function continueConversationFromResult(card) {
            if (!card) return;
            const responseText = (card.dataset.responseText || '').trim();
            if (!responseText) {
                alert('No response text available to continue.');
                return;
            }
            addConversationRound('assistant', responseText, true);
            const userRound = addConversationRound('user', '', true);
            if (userRound) {
                userRound.scrollIntoView({ behavior: 'smooth', block: 'center' });
                const textarea = userRound.querySelector('textarea');
                if (textarea) {
                    requestAnimationFrame(() => textarea.focus());
                }
            }
        }

        function getConversationRoundsFromDOM() {
            const roundElements = document.getElementById('conversationRoundsContainer').children;

            return Array.from(roundElements).map(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                return {
                    role: select ? select.value : 'user',
                    message: textarea ? textarea.value : ''
                };
            });
        }

        // Function to save conversation rounds to local storage
        function saveConversationRounds() {
            const rounds = getConversationRoundsFromDOM();
            localStorage.setItem('saved_conversation_rounds', JSON.stringify(rounds));
        }

        // Save prompts as user types
        document.getElementById('systemPrompt').addEventListener('input', (e) => {
            localStorage.setItem('saved_system_prompt', e.target.value);
            markPromptsModified();
        });

        function getStoredApiKey(provider) {
            const config = API_CONFIGS[provider];
            if (!config) return '';

            if (config.storageKey) {
                return localStorage.getItem(config.storageKey) || '';
            }

            const custom = getCustomProvider(provider);
            return custom?.apiKey || '';
        }

        function setStoredApiKey(provider, value) {
            const config = API_CONFIGS[provider];
            if (!config) return;

            if (config.storageKey) {
                if (value) {
                    localStorage.setItem(config.storageKey, value);
                } else {
                    localStorage.removeItem(config.storageKey);
                }
                if (provider === 'openrouter') {
                    if (value) {
                        refreshOpenRouterModelCache();
                    } else {
                        setOpenRouterModelStatus('OpenRouter key cleared.', 'text-base-1');
                    }
                }
                return;
            }

            const custom = getCustomProvider(provider);
            if (custom) {
                custom.apiKey = value || '';
                persistCustomProviders();
            }
        }

        function updateKeyIndicator(provider) {
            const indicator = document.querySelector(`.key-indicator[data-provider="${provider}"]`);
            const clearButton = document.querySelector(`.clear-key-button[data-provider="${provider}"]`);
            if (!indicator) return;
            
            const hasKey = Boolean(getStoredApiKey(provider));
            indicator.classList.toggle('visible', hasKey);
            if (clearButton) {
                clearButton.classList.toggle('visible', hasKey);
            }
        }

        function updateAllKeyIndicators() {
            getAllProviderIds().forEach(updateKeyIndicator);
        }

        function renderSecurityKeyManager() {
            const container = document.getElementById('securityKeyManager');
            if (!container) return;

            container.innerHTML = '';
            const providers = getAllProviderIds();
            const storedPat = localStorage.getItem(GITHUB_PAT_STORAGE_KEY) || '';

            const patWrapper = document.createElement('div');
            patWrapper.className = 'border border-base-1/20 p-4 bg-base-2 rounded';
            patWrapper.innerHTML = `
                <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                    <div>
                        <div class="text-base-00 text-sm font-semibold">GitHub Gist PAT</div>
                        <div class="text-xs text-base-1">Storage: ${GITHUB_PAT_STORAGE_KEY}</div>
                    </div>
                    <div class="text-sm ${storedPat ? 'text-sol-green' : 'text-base-1'}">${storedPat ? 'Key Saved' : 'No Key'}</div>
                </div>
                <div class="mt-3 grid gap-2 sm:grid-cols-[1fr_auto_auto]">
                    <input type="password" class="form-input" data-security-pat placeholder="Paste new token...">
                    <button class="btn-success text-xs" data-security-pat-save>Save</button>
                    <button class="btn-danger text-xs" data-security-pat-clear>Clear</button>
                </div>
                <div class="mt-2 text-xs text-base-1">Used only for saving private gists.</div>
            `;
            container.appendChild(patWrapper);
            const patInput = patWrapper.querySelector('[data-security-pat]');
            if (patInput) {
                patInput.value = storedPat;
            }

            if (!providers.length) {
                const empty = document.createElement('div');
                empty.className = 'text-sm text-base-1';
                empty.textContent = 'No providers detected.';
                container.appendChild(empty);
                return;
            }

            providers.forEach(provider => {
                const wrapper = document.createElement('div');
                wrapper.className = 'border border-base-1/20 p-4 bg-base-2 rounded';

                const displayName = getProviderDisplayName(provider);
                const storedKey = getStoredApiKey(provider);
                const storageLabel = getProviderStorageLabel(provider);

                wrapper.innerHTML = `
                    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                        <div>
                            <div class="text-base-00 text-sm font-semibold">${displayName}</div>
                            <div class="text-xs text-base-1">Storage: ${storageLabel}</div>
                        </div>
                        <div class="text-sm ${storedKey ? 'text-sol-green' : 'text-base-1'}">${storedKey ? 'Key Saved' : 'No Key'}</div>
                    </div>
                    <div class="mt-3 grid gap-2 sm:grid-cols-[1fr_auto_auto]">
                        <input type="password" class="form-input" data-security-provider="${provider}" placeholder="Paste new key...">
                        <button class="btn-success text-xs" data-security-save="${provider}">Save</button>
                        <button class="btn-danger text-xs" data-security-clear="${provider}">Clear</button>
                    </div>
                    <div class="mt-2 text-xs text-base-1">Replace the stored key or clear it to remove from local storage.</div>
                `;

                container.appendChild(wrapper);
                const input = wrapper.querySelector(`input[data-security-provider="${provider}"]`);
                if (input) {
                    input.value = storedKey;
                }
            });

            container.querySelectorAll('[data-security-save]').forEach(button => {
                button.addEventListener('click', () => {
                    const provider = button.dataset.securitySave;
                    const input = container.querySelector(`input[data-security-provider="${provider}"]`);
                    if (!provider || !input) return;
                    const nextValue = input.value.trim();
                    setStoredApiKey(provider, nextValue);
                    updateKeyIndicator(provider);
                    const customApiInput = document.querySelector(`input[data-provider-id="${provider}"][data-field="apiKey"]`);
                    if (customApiInput) {
                        customApiInput.value = nextValue;
                    }
                    renderSecurityKeyManager();
                });
            });

            container.querySelectorAll('[data-security-clear]').forEach(button => {
                button.addEventListener('click', () => {
                    const provider = button.dataset.securityClear;
                    if (!provider) return;
                    setStoredApiKey(provider, '');
                    updateKeyIndicator(provider);
                    const input = container.querySelector(`input[data-security-provider="${provider}"]`);
                    if (input) {
                        input.value = '';
                    }
                    const customApiInput = document.querySelector(`input[data-provider-id="${provider}"][data-field="apiKey"]`);
                    if (customApiInput) {
                        customApiInput.value = '';
                    }
                    renderSecurityKeyManager();
                });
            });

            const patSaveButton = container.querySelector('[data-security-pat-save]');
            if (patSaveButton) {
                patSaveButton.addEventListener('click', () => {
                    const input = container.querySelector('[data-security-pat]');
                    if (!input) return;
                    const nextValue = input.value.trim();
                    if (nextValue) {
                        localStorage.setItem(GITHUB_PAT_STORAGE_KEY, nextValue);
                    } else {
                        localStorage.removeItem(GITHUB_PAT_STORAGE_KEY);
                    }
                    renderSecurityKeyManager();
                });
            }

            const patClearButton = container.querySelector('[data-security-pat-clear]');
            if (patClearButton) {
                patClearButton.addEventListener('click', () => {
                    localStorage.removeItem(GITHUB_PAT_STORAGE_KEY);
                    renderSecurityKeyManager();
                });
            }
        }

        function getApiKey(provider) {
            const config = API_CONFIGS[provider];
            if (!config) return '';

            let apiKey = getStoredApiKey(provider);
            
            if (!apiKey && config.promptForKey !== false) {
                apiKey = window.prompt(`Enter your ${config.name} API key:`);
                if (apiKey) {
                    setStoredApiKey(provider, apiKey);
                    updateKeyIndicator(provider);
                    if (document.getElementById('tab-security')?.classList.contains('hidden') === false) {
                        renderSecurityKeyManager();
                    }
                }
            }
            
            return apiKey || '';
        }

        function clearApiKey(provider) {
            setStoredApiKey(provider, '');
            updateKeyIndicator(provider);
            if (document.getElementById('tab-security')?.classList.contains('hidden') === false) {
                renderSecurityKeyManager();
            }
        }

        function createResultCard(provider, model) {
            const cardId = `result-${provider}-${model.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const card = document.createElement('div');
            card.className = 'border border-base-1/20 p-4 bg-base-2 rounded shadow-sm';
            card.id = cardId;
            const pricingSourceHTML = buildPricingSourceHTML(provider);
            card.innerHTML = `
                <div class="flex items-center justify-between mb-4 pb-2.5 border-b border-base-1/20">
                    <div>
                        <div class="text-base-00 text-sm font-semibold">${getProviderDisplayName(provider)}</div>
                        <div class="text-[13px] text-base-1 mt-0.5">${model}</div>
                    </div>
                    <div class="result-status text-xs text-sol-cyan">Loading...</div>
                </div>
                <div class="result-content text-base-01 leading-relaxed">
                    <div class="flex gap-2 mb-3">
                        <button class="result-tab-btn btn-secondary text-xs" data-tab="text">Text</button>
                        <button class="result-tab-btn btn-primary text-xs" data-tab="markdown">Markdown</button>
                        <button class="result-tab-btn btn-secondary text-xs" data-tab="cost">Cost</button>
                    </div>
                    <div class="border border-base-1/20 p-3 min-h-[120px] bg-base-3 rounded">
                        <div class="tab-panel whitespace-pre-wrap break-words text-[13px]" data-tab="text">
                            <div class="flex items-center justify-center min-h-[120px]">
                                <div class="inline-block w-4 h-4 border-2 border-base-1 border-t-sol-cyan rounded-full animate-spin"></div>
                            </div>
                        </div>
                        <div class="tab-panel hidden prose prose-sm max-w-none text-base-00 text-[13px]" data-tab="markdown"></div>
                        <div class="tab-panel hidden text-[13px]" data-tab="cost">
                            <p class="text-base-1">Cost details will appear after a successful response.</p>
                            ${pricingSourceHTML}
                        </div>
                    </div>
                </div>
                <div class="mt-4 flex justify-end">
                    <button class="btn-secondary text-xs continue-conversation disabled:opacity-40 disabled:cursor-not-allowed" disabled>Continue conversation</button>
                </div>
            `;

            const tabButtons = card.querySelectorAll('.result-tab-btn');
            const tabPanels = card.querySelectorAll('.tab-panel');

            const setActiveTab = (tab) => {
                tabButtons.forEach(btn => {
                    const isActive = btn.dataset.tab === tab;
                    if (isActive) {
                        btn.className = 'result-tab-btn btn-primary text-xs';
                    } else {
                        btn.className = 'result-tab-btn btn-secondary text-xs';
                    }
                });

                tabPanels.forEach(panel => {
                    panel.classList.toggle('hidden', panel.dataset.tab !== tab);
                });
            };

            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => setActiveTab(btn.dataset.tab));
            });
            setActiveTab('markdown');
            const continueButton = card.querySelector('.continue-conversation');
            if (continueButton) {
                continueButton.addEventListener('click', () => {
                    continueConversationFromResult(card);
                });
            }
            return card;
        }

        function updateResultCard(provider, model, status, content, inputText = '', outputText = '', durationMs = null, errorHtml = '') {
            const cardId = `result-${provider}-${model.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const card = document.getElementById(cardId);
            const statusEl = card.querySelector('.result-status');
            const textPanel = card.querySelector('.tab-panel[data-tab="text"]');
            const markdownPanel = card.querySelector('.tab-panel[data-tab="markdown"]');
            const costPanel = card.querySelector('.tab-panel[data-tab="cost"]');
            const pricingSourceHTML = buildPricingSourceHTML(provider);

            const statusClasses = status === 'success'
                ? 'text-xs text-sol-green'
                : 'text-xs text-sol-red';
            statusEl.className = `result-status ${statusClasses}`;
            const statusLabel = status === 'success' ? '● OK' : '● Error';
            const durationLabel = Number.isFinite(durationMs) ? `${Math.round(durationMs)}ms` : '';
            statusEl.textContent = durationLabel ? `${statusLabel} ${durationLabel}` : statusLabel;

            if (costPanel) {
                costPanel.innerHTML = '<p class="text-base-1">Cost details will appear after a successful response.</p>' + pricingSourceHTML;
            }

            const rawText = typeof content === 'string' ? content : '';
            if (status === 'success') {
                card.dataset.responseText = rawText;
            } else {
                card.dataset.responseText = '';
            }
            const continueButton = card.querySelector('.continue-conversation');
            if (continueButton) {
                continueButton.disabled = !(status === 'success' && rawText.trim());
            }
            if (textPanel) {
                textPanel.textContent = rawText;
            }
            if (markdownPanel) {
                if (status === 'success') {
                    if (window.marked) {
                        markdownPanel.innerHTML = DOMPurify.sanitize(window.marked.parse(rawText));
                    } else {
                        markdownPanel.textContent = rawText;
                    }
                } else {
                    if (errorHtml) {
                        markdownPanel.innerHTML = DOMPurify.sanitize(errorHtml);
                    } else {
                        markdownPanel.innerHTML = DOMPurify.sanitize(`<p class="text-sol-red">${rawText || 'No content'}</p>`);
                    }
                }
            }

            if (status === 'success' && inputText && outputText) {
                // Count tokens
                const inputTokens = countTokens(inputText);
                const outputTokens = countTokens(outputText);

                // Calculate pricing
                const pricing = calculatePricing(provider, model, inputTokens, outputTokens);

                // Build pricing display
                const priceClass = pricing.isUnknown ? 'text-sol-red italic' : '';
                const tokenInfoHTML = `
                    <div class="p-2.5 border border-base-1/20 text-[13px] leading-snug bg-base-2 rounded">
                        <div class="flex justify-between py-0.5">
                            <span class="text-base-1 uppercase text-xs tracking-wider">Input Tokens:</span>
                            <span class="text-base-00">${inputTokens.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between py-0.5">
                            <span class="text-base-1 uppercase text-xs tracking-wider">Input Price:</span>
                            <span class="text-base-00 ${priceClass}">${pricing.inputPrice}</span>
                        </div>
                        <div class="flex justify-between py-0.5">
                            <span class="text-base-1 uppercase text-xs tracking-wider">Output Tokens:</span>
                            <span class="text-base-00">${outputTokens.toLocaleString()}</span>
                        </div>
                        <div class="flex justify-between py-0.5">
                            <span class="text-base-1 uppercase text-xs tracking-wider">Output Price:</span>
                            <span class="text-base-00 ${priceClass}">${pricing.outputPrice}</span>
                        </div>
                        <div class="flex justify-between py-0.5 pt-1.5 border-t border-base-1/20 text-base-00 font-semibold">
                            <span class="uppercase text-xs tracking-wider">Total Price:</span>
                            <span class="${priceClass}">${pricing.totalPrice}</span>
                        </div>
                    </div>
                    ${pricingSourceHTML}
                `;

                if (costPanel) {
                    costPanel.innerHTML = tokenInfoHTML;
                }
            } else if (costPanel) {
                costPanel.innerHTML = '<p class="text-base-1">Cost details unavailable.</p>' + pricingSourceHTML;
            }
        }

        function escapeHtml(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function isLikelyCorsError(error) {
            const message = (error?.message || '').toLowerCase();
            return message.includes('failed to fetch')
                || message.includes('networkerror')
                || message.includes('cors');
        }

        function buildApiErrorDisplay(provider, error) {
            const message = error?.message || 'Unknown error';
            if (getCustomProvider(provider) && isLikelyCorsError(error)) {
                const text = `CORS error: ${message}\nFix this for Ollama: ${OLLAMA_CORS_HELP_URL}`;
                const html = `
                    <div class="space-y-2 text-[13px]">
                        <p class="text-sol-red">CORS error: ${escapeHtml(message)}</p>
                        <a class="text-sol-cyan underline" href="${OLLAMA_CORS_HELP_URL}" target="_blank" rel="noopener">Fix this for Ollama</a>
                    </div>
                `;
                return { text, html };
            }
            return { text: `Error: ${message}`, html: '' };
        }

        function buildOpenAIStyleMessages(systemPrompt) {
            const messages = [];

            if (systemPrompt.trim()) {
                messages.push({ role: 'system', content: systemPrompt });
            }

            const roundElements = document.getElementById('conversationRoundsContainer').children;
            Array.from(roundElements).forEach(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                if (textarea.value.trim()) {
                    messages.push({ role: select.value, content: textarea.value });
                }
            });

            return messages;
        }

        function normalizeChatCompletionEndpoint(endpoint) {
            if (!endpoint) return '';
            const trimmed = endpoint.trim().replace(/\/+$/, '');
            if (trimmed.toLowerCase().endsWith('/chat/completions')) {
                return trimmed;
            }
            return `${trimmed}/chat/completions`;
        }

        async function callOpenAICompatible(systemPrompt, apiKey, model, endpoint, extraHeaders = {}) {
            const normalizedEndpoint = normalizeChatCompletionEndpoint(endpoint);
            if (!normalizedEndpoint) {
                throw new Error('API endpoint is required for this provider.');
            }

            const messages = buildOpenAIStyleMessages(systemPrompt);
            const headers = {
                'Content-Type': 'application/json',
                ...extraHeaders
            };

            if (apiKey) {
                headers['Authorization'] = `Bearer ${apiKey}`;
            }

            const response = await fetch(normalizedEndpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    model: model,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content;
            if (!content) {
                throw new Error('No content returned from provider.');
            }
            return content;
        }

        async function callOpenAI(systemPrompt, apiKey, model) {
            return callOpenAICompatible(systemPrompt, apiKey, model, API_CONFIGS.openai.endpoint);
        }

        async function callAnthropic(systemPrompt, apiKey, model) {
            // Build messages array with conversation rounds
            const messages = [];

            // Add conversation rounds
            const roundElements = document.getElementById('conversationRoundsContainer').children;
            Array.from(roundElements).forEach(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                if (textarea.value.trim()) {
                    messages.push({ role: select.value, content: textarea.value });
                }
            });

            const response = await fetch(API_CONFIGS.anthropic.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: model,
                    max_tokens: 1000,
                    system: systemPrompt,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.content[0].text;
        }

        async function callGemini(systemPrompt, apiKey, model) {
            // Build conversation history
            let conversationText = systemPrompt;

            // Add conversation rounds
            const roundElements = document.getElementById('conversationRoundsContainer').children;
            Array.from(roundElements).forEach(element => {
                const select = element.querySelector('select');
                const textarea = element.querySelector('textarea');

                if (textarea.value.trim()) {
                    conversationText += `\n\n${select.value.toUpperCase()}: ${textarea.value}`;
                }
            });

            const response = await fetch(`${API_CONFIGS.gemini.endpoint}/${model}:generateContent`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-goog-api-key': apiKey
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: conversationText
                        }]
                    }]
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`HTTP ${response.status}: ${error}`);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        async function callOpenRouter(systemPrompt, apiKey, model) {
            const headers = {
                'HTTP-Referer': window.location.href,
                'X-Title': 'LLM Comparator'
            };
            return callOpenAICompatible(systemPrompt, apiKey, model, API_CONFIGS.openrouter.endpoint, headers);
        }

        async function callAPI(provider, model, systemPrompt, apiKey) {
            const config = API_CONFIGS[provider];
            if (!config) {
                throw new Error('Unknown API');
            }

            const requiresKey = config.requiresApiKey !== false;
            if (!apiKey && requiresKey) {
                throw new Error('API key not provided');
            }

            switch (config.type) {
                case 'openai':
                    return await callOpenAI(systemPrompt, apiKey, model);
                case 'anthropic':
                    return await callAnthropic(systemPrompt, apiKey, model);
                case 'gemini':
                    return await callGemini(systemPrompt, apiKey, model);
                case 'openrouter':
                    return await callOpenRouter(systemPrompt, apiKey, model);
                case 'openai-compatible':
                    return await callOpenAICompatible(systemPrompt, apiKey, model, config.endpoint);
                default:
                    throw new Error('Unknown API');
            }
        }

        function getPromptsPayload() {
            return {
                systemPrompt: document.getElementById('systemPrompt').value || '',
                conversationRounds: getConversationRoundsFromDOM()
            };
        }

        function downloadPromptsAsJSON() {
            const payload = getPromptsPayload();
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'prompts.json';
            link.click();
            URL.revokeObjectURL(url);
        }

        function importPromptsData(parsed) {
            if (typeof parsed !== 'object' || parsed === null) {
                throw new Error('Invalid JSON structure');
            }

            const systemPromptValue = typeof parsed.systemPrompt === 'string' ? parsed.systemPrompt : '';
            const conversationRounds = Array.isArray(parsed.conversationRounds) ? parsed.conversationRounds : [];

            const systemPromptEl = document.getElementById('systemPrompt');
            systemPromptEl.value = systemPromptValue;
            localStorage.setItem('saved_system_prompt', systemPromptValue);

            const container = document.getElementById('conversationRoundsContainer');
            container.innerHTML = '';

            conversationRounds.forEach(round => {
                const role = round && round.role === 'assistant' ? 'assistant' : 'user';
                const message = round && typeof round.message === 'string' ? round.message : '';
                addConversationRound(role, message, false);
            });

            saveConversationRounds();
        }

        function handlePromptsFileUpload(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const parsed = JSON.parse(event.target?.result || '{}');
                    importPromptsData(parsed);
                } catch (error) {
                    console.error('Failed to import prompts:', error);
                    alert('Invalid prompts file. Please upload a valid JSON export.');
                } finally {
                    const uploadInput = document.getElementById('uploadPromptsFile');
                    if (uploadInput) {
                        uploadInput.value = '';
                    }
                }
            };

            reader.readAsText(file);
        }

        document.getElementById('downloadPrompts').addEventListener('click', downloadPromptsAsJSON);

        const uploadPromptsFileInput = document.getElementById('uploadPromptsFile');
        document.getElementById('uploadPrompts').addEventListener('click', () => {
            if (uploadPromptsFileInput) {
                uploadPromptsFileInput.value = '';
                uploadPromptsFileInput.click();
            }
        });

        if (uploadPromptsFileInput) {
            uploadPromptsFileInput.addEventListener('change', (event) => {
                const file = event.target.files && event.target.files[0];
                if (file) {
                    handlePromptsFileUpload(file);
                }
            });
        }

        function extractGistId(input) {
            if (!input) return '';
            const trimmed = input.trim();
            try {
                const asUrl = new URL(trimmed);
                const parts = asUrl.pathname.split('/').filter(Boolean);
                return parts[parts.length - 1] || '';
            } catch {
                // Not a URL; assume raw id or short form
            }

            const match = trimmed.match(/[0-9a-f]{8,}/i);
            return match ? match[0] : '';
        }

        function updateUrlWithGistId(gistId) {
            const url = new URL(window.location.href);
            if (gistId) {
                url.searchParams.set('gist', gistId);
            } else {
                url.searchParams.delete('gist');
            }
            url.searchParams.delete('history');
            window.history.replaceState({}, '', url);
        }

        function clearGistAndHistoryParams() {
            const url = new URL(window.location.href);
            url.searchParams.delete('gist');
            url.searchParams.delete('history');
            window.history.replaceState({}, '', url);
            if (gistInput) {
                gistInput.value = '';
            }
            if (gistStatus) {
                gistStatus.textContent = '';
            }
        }

        function markPromptsModified() {
            clearGistAndHistoryParams();
        }

        async function fetchGistAndImport(gistId, setStatus) {
            if (!window.Octokit) {
                alert('Octokit failed to load. Please refresh and try again.');
                return false;
            }

            const octokit = new window.Octokit();
            setStatus('Loading gist...', 'text-base-1');
            try {
                const response = await octokit.request('GET /gists/{gist_id}', {
                    gist_id: gistId,
                    headers: {
                        'X-GitHub-Api-Version': '2022-11-28'
                    }
                });

                const files = response.data.files || {};
                const fileList = Object.values(files);
                if (!fileList.length) throw new Error('No files found in gist.');

                const selectedFile = fileList.find(f =>
                    (f.filename || '').toLowerCase().endsWith('.json') ||
                    (f.language || '').toLowerCase() === 'json'
                ) || fileList[0];

                if (!selectedFile || !selectedFile.content) {
                    throw new Error('No readable file content found.');
                }

                const parsed = JSON.parse(selectedFile.content);
                importPromptsData(parsed);
                setStatus(`Loaded from ${selectedFile.filename || 'gist file'}`, 'text-sol-green');
                return true;
            } catch (error) {
                console.error('Gist load failed:', error);
                alert('Failed to load gist. Please check the URL/ID and try again.');
                setStatus('Failed to load gist.', 'text-sol-red');
                return false;
            }
        }

        function setGistStatus(message, cls = 'text-base-1') {
            if (gistStatus) {
                gistStatus.className = `text-xs ${cls}`;
                gistStatus.textContent = message;
            }
        }

        function setGistSaveStatus(message, cls = 'text-base-1') {
            if (gistSaveStatus) {
                gistSaveStatus.className = `text-xs ${cls}`;
                gistSaveStatus.textContent = message;
            }
        }

        function setSlidePanelOpen(panel, open) {
            if (!panel) return;
            panel.classList.toggle('open', open);
        }

        async function createPrivateGist(token) {
            if (!window.Octokit) {
                throw new Error('Octokit failed to load.');
            }

            const payload = getPromptsPayload();
            const octokit = new window.Octokit({ auth: token });
            const response = await octokit.request('POST /gists', {
                description: 'LLM Comparator prompts',
                public: false,
                files: {
                    [GIST_EXPORT_FILENAME]: {
                        content: JSON.stringify(payload, null, 2)
                    }
                },
                headers: {
                    'X-GitHub-Api-Version': '2022-11-28'
                }
            });

            return response.data;
        }

        function buildUrlWithGistId(gistId) {
            const url = new URL(window.location.href);
            url.searchParams.set('gist', gistId);
            url.searchParams.delete('history');
            return url.toString();
        }

        async function handleSaveToGist() {
            const token = localStorage.getItem(GITHUB_PAT_STORAGE_KEY);
            if (!token) {
                setSlidePanelOpen(gistSaveResult, false);
                setSlidePanelOpen(gistSavePanel, true);
                gistTokenInput?.focus();
                return;
            }

            try {
                setSlidePanelOpen(gistSavePanel, false);
                setGistSaveStatus('');
                setSlidePanelOpen(gistSaveResult, false);
                setGistSaveStatus('Saving gist...', 'text-base-1');
                const data = await createPrivateGist(token);
                const gistUrl = data.html_url || '';
                const gistId = data.id || '';
                const loadUrl = gistId ? buildUrlWithGistId(gistId) : '';

                if (gistResultLink) {
                    gistResultLink.href = gistUrl || '#';
                    gistResultLink.textContent = gistUrl || 'Gist link';
                }
                if (gistLoadLink) {
                    gistLoadLink.href = loadUrl || '#';
                    gistLoadLink.textContent = loadUrl || 'Open this page with gist loaded';
                }
                if (copyGistLink) {
                    copyGistLink.dataset.copyValue = gistUrl || '';
                }
                if (copyGistLoadLink) {
                    copyGistLoadLink.dataset.copyValue = loadUrl || '';
                }

                setGistSaveStatus('Gist created.', 'text-sol-green');
                setSlidePanelOpen(gistSaveResult, true);
            } catch (error) {
                console.error('Failed to save gist:', error);
                alert('Failed to save gist. Please check your token and try again.');
                setGistSaveStatus('Failed to save gist.', 'text-sol-red');
                setSlidePanelOpen(gistSaveResult, false);
            }
        }

        async function copyToClipboard(value) {
            if (!value) return;
            try {
                await navigator.clipboard.writeText(value);
                setGistSaveStatus('Copied to clipboard.', 'text-sol-green');
            } catch (error) {
                console.error('Clipboard copy failed:', error);
                setGistSaveStatus('Copy failed. Please copy manually.', 'text-sol-red');
            }
        }

        const gistToggleButton = document.getElementById('loadFromGist');
        const gistLoader = document.getElementById('gistLoader');
        const gistInput = document.getElementById('gistInput');
        const gistStatus = document.getElementById('gistStatus');
        const fetchGistButton = document.getElementById('fetchGistButton');
        const saveToGistButton = document.getElementById('saveToGist');
        const gistSavePanel = document.getElementById('gistSavePanel');
        const gistSaveResult = document.getElementById('gistSaveResult');
        const gistTokenInput = document.getElementById('gistTokenInput');
        const saveGistTokenButton = document.getElementById('saveGistTokenButton');
        const gistSaveStatus = document.getElementById('gistSaveStatus');
        const gistResultLink = document.getElementById('gistResultLink');
        const gistLoadLink = document.getElementById('gistLoadLink');
        const copyGistLink = document.getElementById('copyGistLink');
        const copyGistLoadLink = document.getElementById('copyGistLoadLink');

        if (gistToggleButton && gistLoader) {
            gistToggleButton.addEventListener('click', () => {
                gistLoader.classList.toggle('hidden');
                gistStatus.textContent = '';
                if (!gistLoader.classList.contains('hidden')) {
                    gistInput?.focus();
                }
            });
        }

        if (fetchGistButton) {
            fetchGistButton.addEventListener('click', () => {
                const id = extractGistId(gistInput?.value || '');
                if (!id) {
                    alert('Please enter a valid Gist URL or ID.');
                    return;
                }
                fetchGistAndImport(id, setGistStatus).then(success => {
                    if (success) {
                        updateUrlWithGistId(id);
                    }
                });
            });
        }

        if (saveToGistButton) {
            saveToGistButton.addEventListener('click', () => {
                handleSaveToGist();
            });
        }

        if (saveGistTokenButton) {
            saveGistTokenButton.addEventListener('click', () => {
                const token = (gistTokenInput?.value || '').trim();
                if (!token) {
                    setGistSaveStatus('Please enter a token first.', 'text-sol-red');
                    return;
                }
                localStorage.setItem(GITHUB_PAT_STORAGE_KEY, token);
                gistTokenInput.value = '';
                setGistSaveStatus('Token saved.', 'text-sol-green');
                handleSaveToGist();
            });
        }

        if (copyGistLink) {
            copyGistLink.addEventListener('click', () => {
                copyToClipboard(copyGistLink.dataset.copyValue || '');
            });
        }

        if (copyGistLoadLink) {
            copyGistLoadLink.addEventListener('click', () => {
                copyToClipboard(copyGistLoadLink.dataset.copyValue || '');
            });
        }

        // Add conversation round button handler
        document.getElementById('addConversationRound').addEventListener('click', () => {
            addConversationRound();
        });

        const addCustomProviderButton = document.getElementById('addCustomProviderButton');
        if (addCustomProviderButton) {
            addCustomProviderButton.addEventListener('click', () => {
                addCustomProvider();
                getAllProviderIds().forEach(attachSaveButtonHandler);
            });
        }

        function attachSaveButtonHandler(provider) {
            const button = document.getElementById(`${provider}-save-model`);
            const input = document.getElementById(`${provider}-custom`);
            if (!button || !input) return;

            if (button.dataset.bound === 'true') return;
            button.dataset.bound = 'true';

            button.addEventListener('click', () => {
                const trimmed = input.value.trim();
                if (!trimmed) {
                    alert('Please enter a model name to save');
                    return;
                }

                const added = addSavedModel(provider, trimmed);
                if (!added) {
                    alert('Model already saved');
                    return;
                }

                input.value = '';
            });
        }

        document.addEventListener('click', (event) => {
            const button = event.target.closest('.clear-key-button');
            if (!button) return;
            const provider = button.dataset.provider;
            if (!provider) return;
            if (confirm(`Clear saved ${getProviderDisplayName(provider)} API key?`)) {
                clearApiKey(provider);
                const apiInput = document.querySelector(`input[data-provider-id="${provider}"][data-field="apiKey"]`);
                if (apiInput) {
                    apiInput.value = '';
                }
            }
        });

        function syncProviderPanel(checkbox) {
            const provider = checkbox.dataset.provider;
            const modelOptions = document.getElementById(`${provider}-models`);
            if (!modelOptions) return;
            modelOptions.classList.toggle('active', checkbox.checked);
        }

        function setupProviderCheckboxes() {
            document.querySelectorAll('.provider-checkbox').forEach(checkbox => {
                if (checkbox.dataset.bound === 'true') return;
                checkbox.dataset.bound = 'true';

                checkbox.addEventListener('change', function() {
                    syncProviderPanel(this);
                });
                syncProviderPanel(checkbox);
            });
        }

        document.addEventListener('change', (event) => {
            const target = event.target;
            if (target && target.matches('input[type="checkbox"][data-provider][data-model]')) {
                const provider = target.dataset.provider;
                const model = target.dataset.model;
                setModelSelected(provider, model, target.checked);
            }
        });

        function getSelectedModels() {
            const selections = [];
            
            document.querySelectorAll('.provider-checkbox:checked').forEach(providerCheckbox => {
                const provider = providerCheckbox.dataset.provider;
                
                // Get checked model checkboxes
                const modelCheckboxes = document.querySelectorAll(`input[type="checkbox"][data-provider="${provider}"][data-model]`);
                modelCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        selections.push({
                            provider: provider,
                            model: checkbox.dataset.model
                        });
                    }
                });
                
                // Get custom model input
                const customInput = document.getElementById(`${provider}-custom`);
                if (customInput && customInput.value.trim()) {
                    selections.push({
                        provider: provider,
                        model: customInput.value.trim()
                    });
                }
            });
            
            return selections;
        }

        function persistSelectionsToStorage(selections) {
            selections.forEach(selection => {
                setModelSelected(selection.provider, selection.model, true);
            });
            applySelectedModelsToCheckboxes();
        }

        document.getElementById('sendButton').addEventListener('click', async () => {
            const selections = getSelectedModels();

            if (selections.length === 0) {
                alert('Please select at least one provider and model');
                return;
            }

            const systemPrompt = document.getElementById('systemPrompt').value;

            // Check that conversation rounds have content
            const roundElements = document.getElementById('conversationRoundsContainer').children;
            const hasConversationContent = Array.from(roundElements).some(el =>
                el.querySelector('textarea').value.trim()
            );
            
            if (!hasConversationContent) {
                alert('Please add at least one conversation round');
                return;
            }

            getAllProviderIds().forEach(provider => {
                const customInput = document.getElementById(`${provider}-custom`);
                if (!customInput) return;
                const customValue = customInput.value.trim();
                const customUsed = selections.some(sel => sel.provider === provider && sel.model === customValue);
                if (customValue && customUsed) {
                    addSavedModel(provider, customValue);
                    setModelSelected(provider, customValue, true);
                }
            });

            persistSelectionsToStorage(selections);

            // Get unique providers that need API keys
            const uniqueProviders = [...new Set(selections.map(s => s.provider))];
            
            // Prompt for API keys upfront for all providers
            const apiKeys = {};
            for (const provider of uniqueProviders) {
                const config = API_CONFIGS[provider] || {};
                const key = getApiKey(provider);
                if (!key && config.requiresApiKey !== false) {
                    alert(`API key required for ${getProviderDisplayName(provider)}`);
                    return;
                }
                apiKeys[provider] = key || '';
            }

            const resultsGrid = document.getElementById('resultsGrid');
            resultsGrid.innerHTML = '';

            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;

            // Combined input text for token counting
            let inputText = systemPrompt;
            Array.from(roundElements).forEach(el => {
                const content = el.querySelector('textarea').value;
                if (content.trim()) {
                    inputText += '\n\n' + content;
                }
            });

            // Create result cards for all selections
            selections.forEach(selection => {
                const card = createResultCard(selection.provider, selection.model);
                resultsGrid.appendChild(card);
            });

            // Call all APIs concurrently
            const apiPromises = selections.map(selection => {
                const startTime = performance.now();
                return callAPI(selection.provider, selection.model, systemPrompt, apiKeys[selection.provider])
                    .then(result => {
                        const durationMs = performance.now() - startTime;
                        updateResultCard(selection.provider, selection.model, 'success', result, inputText, result, durationMs);
                    })
                    .catch(error => {
                        const durationMs = performance.now() - startTime;
                        const errorDisplay = buildApiErrorDisplay(selection.provider, error);
                        updateResultCard(
                            selection.provider,
                            selection.model,
                            'error',
                            errorDisplay.text,
                            '',
                            '',
                            durationMs,
                            errorDisplay.html
                        );
                    });
            });

            await Promise.all(apiPromises);

            sendButton.disabled = false;
        });

        </script>
        <footer class="max-w-6xl mx-auto mt-12 pb-8 flex flex-wrap justify-center gap-4 text-xs tracking-wide text-base-1">
            <span class="text-base-01">A tool by Nick Lothian © 2026</span>
            <span class="text-base-01">·</span>
            <a href="https://x.com/nlothian" class="text-sol-cyan hover:text-base-01 transition-colors">X</a>
            <span class="text-base-01">·</span>
            <a href="https://bsky.app/profile/nlothian.bsky.social" class="text-sol-cyan hover:text-base-01 transition-colors">Bluesky</a>
            <span class="text-base-01">·</span>
            <a href="https://github.com/nlothian/tools/blob/main/llm_comparator.html" class="text-sol-cyan hover:text-base-01 transition-colors">source code</a>
            <span class="text-base-01">·</span>
            <a href="https://github.com/nlothian/tools/blob/main/LICENSE" class="text-sol-cyan hover:text-base-01 transition-colors">License</a>
        </footer>
</body>
</html>
